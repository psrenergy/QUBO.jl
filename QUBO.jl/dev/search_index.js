var documenterSearchIndex = {"docs":
[{"location":"examples/knapsack/#Knapsack","page":"Knapsack","title":"Knapsack","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"We start with some instances of the discrete Knapsack Problem whose standard formulation is","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"beginarrayr l\n    max         mathbfc mathbfx \n    textst  mathbfw mathbfx le C \n                mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"examples/knapsack/#MathOptInterface","page":"Knapsack","title":"MathOptInterface","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"Using MOI directly to build a simple model is pretty straightforward. All that one has to do is to use MOI.instantiate and define the model as usual.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"import MathOptInterface as MOI\nconst MOIU = MOI.Utilities\n\nusing ToQUBO\nusing DWaveNeal # <- Your favourite Annealer / Sampler / Solver here\n\n# Example from https://jump.dev/MathOptInterface.jl/stable/tutorials/example/\n\n# Virtual QUBO Model\nmodel = MOI.instantiate(\n   () -> ToQUBO.Optimizer(DWaveNeal.Optimizer),\n   with_bridge_type = Float64,\n)\n\nn = 3;\nc = [1.0, 2.0, 3.0]\nw = [0.3, 0.5, 1.0]\nC = 3.2;\n\nx = MOI.add_variables(model, n);\n\nfor xᵢ in x\n   MOI.add_constraint(model, xᵢ, MOI.ZeroOne())\nend\n\nMOI.set(model, MOI.ObjectiveSense(), MOI.MAX_SENSE)\n\nMOI.set(\n   model,\n   MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n   MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0),\n);\n\nMOI.add_constraint(\n   model,\n   MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(w, x), 0.0),\n   MOI.LessThan(C),\n);\n\nMOI.optimize!(model)\n\n# Collect Solution\nMOI.get.(model, MOI.VariablePrimal(), x)","category":"page"},{"location":"examples/knapsack/#JuMP-D-Wave-Examples","page":"Knapsack","title":"JuMP + D-Wave Examples","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"We may now fill a few more knapsacks using JuMP. We will generate uniform random costs mathbfc and weights mathbfw then set the knapsack's capacity C to be a fraction of the total available weight i.e. 80.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"This example was inspired by D-Wave's knapsack example repository.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using CSV\nusing DataFrames\nusing Random\n\n# Generate Data\nrng = MersenneTwister(1)\n\ndf = DataFrame(\n   :cost   => rand(rng, 1:100, 16),\n   :weight => rand(rng, 1:100, 16),\n)\n\nCSV.write(\"knapsack.csv\", df)","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using CSV\nusing DataFrames\n\ndf = CSV.read(\"knapsack.csv\", DataFrame)","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal # <- Your favourite Annealer/Sampler/Solver here\n\nmodel = Model(() -> ToQUBO.Optimizer(DWaveNeal.Optimizer))\n\nn = size(df, 1)\nc = collect(Float64, df[!, :cost])\nw = collect(Float64, df[!, :weight])\nC = round(0.8 * sum(w))\n\n@variable(model, x[1:n], Bin)\n@objective(model, Max, c' * x)\n@constraint(model, w' * x <= C)\n\noptimize!(model)\n\n# Add Results as a new column\ninsertcols!(df, 3, :select => map((ξ) -> (ξ > 0.0) ? \"Yes\" : \"No\", value.(x)))","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Quick-Start-Guide","page":"Manual","title":"Quick Start Guide","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal # <- Your favourite Annealer/Sampler/Solver here\n\nmodel = Model(() -> ToQUBO.Optimizer(DWaveNeal.Optimizer))\n\n@variable(model, x[1:3], Bin)\n\n@objective(model, Max, 1.0 * x[1] + 2.0 * x[2] + 3.0 * x[3])\n\n@constraint(model, 0.3 * x[1] + 0.5 * x[2] + 1.0 * x[3] <= 1.6)\n\noptimize!(model)\n\nsolution_summary(model)","category":"page"},{"location":"manual/#Compiler-Flags","page":"Manual","title":"Compiler Flags","text":"","category":"section"},{"location":"manual/#Architecture","page":"Manual","title":"Architecture","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"ToQUBO.Attributes.Architecture","category":"page"},{"location":"manual/#ToQUBO.Attributes.Architecture","page":"Manual","title":"ToQUBO.Attributes.Architecture","text":"Architecture()\n\n\n\n\n\n","category":"type"},{"location":"manual/#Quadratization","page":"Manual","title":"Quadratization","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"ToQUBO.Attributes.Quadratize\nToQUBO.Attributes.QuadratizationMethod\nToQUBO.Attributes.StableQuadratization","category":"page"},{"location":"manual/#ToQUBO.Attributes.Quadratize","page":"Manual","title":"ToQUBO.Attributes.Quadratize","text":"Quadratize()\n\nBoolean flag to conditionally perform the quadratization step. Is automatically set by the compiler when high-order functions are generated.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ToQUBO.Attributes.QuadratizationMethod","page":"Manual","title":"ToQUBO.Attributes.QuadratizationMethod","text":"QuadratizationMethod()\n\nDefines which quadratization method to use. Available options are defined in the PBO submodule.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ToQUBO.Attributes.StableQuadratization","page":"Manual","title":"ToQUBO.Attributes.StableQuadratization","text":"StableQuadratization()\n\nWhen set, this boolean flag enables stable quadratization methods, thus yielding predictable results. This is intended to be used during tests or other situations where deterministic output is desired. On the other hand, usage in production is not recommended since it requires increased memory and processing resources.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Variable-and-Constraint-Encoding","page":"Manual","title":"Variable & Constraint Encoding","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"ToQUBO.Attributes.VariableEncodingMethod\nToQUBO.Attributes.VariableEncodingPenalty\nToQUBO.Attributes.ConstraintEncodingPenalty","category":"page"},{"location":"manual/#ToQUBO.Attributes.VariableEncodingMethod","page":"Manual","title":"ToQUBO.Attributes.VariableEncodingMethod","text":"VariableEncodingMethod()\n\nAvailable methods are:\n\nBinary (default)\nUnary\nArithmetic\nOneHot\nDomainWall\nBounded\n\nThe Binary, Unary and Arithmetic encodings can have their expansion coefficients bounded by parametrizing the Bounded encoding.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ToQUBO.Attributes.VariableEncodingPenalty","page":"Manual","title":"ToQUBO.Attributes.VariableEncodingPenalty","text":"VariableEncodingPenalty()\n\nAllows the user to set and retrieve the coefficients used for encoding variables when additional constraints are involved.\n\n\n\n\n\n","category":"type"},{"location":"manual/#ToQUBO.Attributes.ConstraintEncodingPenalty","page":"Manual","title":"ToQUBO.Attributes.ConstraintEncodingPenalty","text":"ConstraintEncodingPenalty()\n\nAllows the user to set and retrieve the coefficients used for encoding constraints.\n\n\n\n\n\n","category":"type"},{"location":"examples/prime_factorization/#Prime-Factorization","page":"Prime Factorization","title":"Prime Factorization","text":"","category":"section"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"A central problem in Number Theory and cryptography is to factor R in mathbbN, which is known to be the product of two distinct prime numbers p q in mathbbN. Shor's Algorithm, designed to address such task is often regarded as one of the major theoretical landmarks in Quantum Computing, being responsible for driving increasingly greater interest to the area.","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"A naïve approach to model this problem can be stated as a quadratically-constrained integer program:","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"beginarrayrl\ntextst  p times q = R \n             p q ge 0     \n             p q in mathbbZ\nendarray","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"From the definition and the basics of number theory, we are able to retrieve a few assumptions about the problem's variables:","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"p and q are bounded to the interval left1 Rright\nMoreover, it is fine to assume 1  p le sqrtR le q le R div 2.","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal\n\nfunction factor(R::Integer; optimizer = DWaveNeal.Optimizer)\n    return factor(identity, R; optimizer = optimizer)\nend\n\nfunction factor(config!::Function, R::Integer; optimizer = DWaveNeal.Optimizer)\n    model = Model(() -> ToQUBO.Optimizer(optimizer))\n\n    @variable(model,  1 <= p <= √R, Int)\n    @variable(model, √R <= q <= R ÷ 2, Int)\n\n    @constraint(model, p * q == R)\n\n    config!(model)\n\n    optimize!(model)\n\n    p = round(Int, value(model[:p]))\n    q = round(Int, value(model[:q]))\n\n    return (p, q)\nend","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"p, q = factor(15) do model\n    set_optimizer_attribute(model, \"num_reads\", 1_000)\n    set_optimizer_attribute(model, \"num_sweeps\", 2_000)\nend\n\nprint(\"$p, $q\")","category":"page"},{"location":"#ToQUBO.jl-Documentation","page":"Home","title":"ToQUBO.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ToQUBO.jl is a Julia Package intended to automatically translate models written in JuMP, into the QUBO mathematical optimization framework.","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"ToQUBO\")","category":"page"},{"location":"#Running","page":"Home","title":"Running","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using JuMP\nusing ToQUBO\nusing Anneal\n\nmodel = Model(() -> ToQUBO.Optimizer(ExactSampler.Optimizer))\n\n@variable(model, x[1:3], Bin)\n\n@objective(model, Max, 1.0*x[1] + 2.0*x[2] + 3.0*x[3])\n\n@constraint(model, 0.3*x[1] + 0.5*x[2] + 1.0*x[3] <= 1.6)\n\noptimize!(model)\n\nfor i = 1:result_count(model)\n    xᵢ = value.(x, result = i)\n    yᵢ = objective_value(model, result = i)\n    println(\"f($xᵢ) = $yᵢ\")\nend","category":"page"},{"location":"#Citing-ToQUBO.jl","page":"Home","title":"Citing ToQUBO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ToQUBO.jl in your work, we kindly ask you to include the following citation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{toqubo:2022,\n  author       = {Pedro Xavier and Tiago Andrade and Joaquim Garcia and David Bernal},\n  title        = {{ToQUBO.jl}},\n  month        = mar,\n  year         = 2022,\n  publisher    = {Zenodo},\n  version      = {v0.1.0},\n  doi          = {10.5281/zenodo.6387592},\n  url          = {https://doi.org/10.5281/zenodo.6387592}\n}","category":"page"},{"location":"booklet/#ToQUBO.jl-Booklet","page":"Booklet","title":"ToQUBO.jl Booklet","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"This booklet aims to gather the theoretical and practical details behind ToQUBO and provide documentation for project internals. The target audience includes, among others, advanced users and those willing to contribute to the project. The latter are advised to read the following sections, as they give a glimpse of the ideas employed up to now.","category":"page"},{"location":"booklet/#QUBO","page":"Booklet","title":"QUBO","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"beginarrayrl\n   min         mathbfx^intercal Qmathbfx \n   textst  mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.isqubo\nToQUBO.toqubo\nToQUBO.toqubo!","category":"page"},{"location":"booklet/#ToQUBO.isqubo","page":"Booklet","title":"ToQUBO.isqubo","text":"isqubo(model::MOI.ModelLike)\n\nTells if a given model is ready to be interpreted as a QUBO model.\n\nFor it to be true, a few conditions must be met:\n\nAll variables must be binary (MOI.VariableIndex ∈ MOI.ZeroOne)\nNo other constraints are allowed\nThe objective function must be of type MOI.ScalarQuadraticFunction, MOI.ScalarAffineFunction or MOI.VariableIndex\nThe objective sense must be either MOI.MIN_SENSE or MOI.MAX_SENSE\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo","page":"Booklet","title":"ToQUBO.toqubo","text":"toqubo(\n    [T=Float64,]\n    source::MOI.ModelLike,\n    ::AbstractArchitecture;\n    optimizer::Union{Nothing, Type{<:MOI.AbstractOptimizer}} = nothing\n)\n\nLow-level interface to create a ::VirtualModel{T} from ::MOI.ModelLike instance. If provided, an ::MOI.AbstractOptimizer is attached to the model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo!","page":"Booklet","title":"ToQUBO.toqubo!","text":"toqubo!(model::VirtualModel{T}, ::AbstractArchitecture) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.toqubo_sense!\nToQUBO.toqubo_variables!\nToQUBO.toqubo_constraint\nToQUBO.toqubo_constraints!\nToQUBO.toqubo_objective!\nToQUBO.toqubo_penalties!\nToQUBO.toqubo_parse!\nToQUBO.toqubo_build!","category":"page"},{"location":"booklet/#ToQUBO.toqubo_sense!","page":"Booklet","title":"ToQUBO.toqubo_sense!","text":"toqubo_sense!(model::VirtualModel, ::AbstractArchitecture) where {T}\n\nCopies MOI.ObjectiveSense from model.source_model to model.target_model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo_variables!","page":"Booklet","title":"ToQUBO.toqubo_variables!","text":"toqubo_variables!(model::VirtualModel{T}) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo_constraint","page":"Booklet","title":"ToQUBO.toqubo_constraint","text":"toqubo_constraint\n\nReturns the pseudo-boolean function associated to a given constraint from the source model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo_constraints!","page":"Booklet","title":"ToQUBO.toqubo_constraints!","text":"toqubo_constraints!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo_objective!","page":"Booklet","title":"ToQUBO.toqubo_objective!","text":"toqubo_objective!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo_penalties!","page":"Booklet","title":"ToQUBO.toqubo_penalties!","text":"toqubo_penalties!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo_parse!","page":"Booklet","title":"ToQUBO.toqubo_parse!","text":"toqubo_parse!(\n    model::VirtualModel{T},\n    g::PBO.PBF{VI,T},\n    f::MOI.AbstractFunction,\n    arch::AbstractArchitectur\n) where {T}\n\nParses the given MOI function f into PBF g.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo_build!","page":"Booklet","title":"ToQUBO.toqubo_build!","text":"toqubo_build!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/#Pseudo-Boolean-Optimization","page":"Booklet","title":"Pseudo-Boolean Optimization","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"Internally, problems are represented through a Pseudo-Boolean Optimization (PBO) framework. The main goal is to represent a given problem using a Pseudo-Boolean Function (PBF) since there is an immediate correspondence between quadratic PBFs and QUBO forms.","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.PBO.PseudoBooleanFunction\nToQUBO.PBO.residual\nToQUBO.PBO.derivative\nToQUBO.PBO.gradient\nToQUBO.PBO.gap\nToQUBO.PBO.sharpness\nToQUBO.PBO.relaxed_gcd","category":"page"},{"location":"booklet/#ToQUBO.PBO.PseudoBooleanFunction","page":"Booklet","title":"ToQUBO.PBO.PseudoBooleanFunction","text":"PseudoBooleanFunction{V,T}(Ω::Dict{Union{Set{V},Nothing},T}) where {V,T}\n\nA Pseudo-Boolean Function[Boros2002] f in mathscrF over some field mathbbT takes the form\n\nf(mathbfx) = sum_omega in Omegaleftfright c_omega prod_j in omega x_j\n\nwhere each Omegaleftfright is the multi-linear representation of f as a set of terms. Each term is given by a unique set of indices omega subseteq mathbbS related to some coefficient c_omega in mathbbT. We say that omega in Omegaleftfright iff c_omega neq 0. Variables x_j are boolean, thus f  mathbbB^n to mathbbT.\n\n[Boros2002]: Endre Boros, Peter L. Hammer, Pseudo-Boolean optimization, Discrete Applied Mathematics, 2002 {doi}\n\n\n\n\n\n","category":"type"},{"location":"booklet/#ToQUBO.PBO.relaxed_gcd","page":"Booklet","title":"ToQUBO.PBO.relaxed_gcd","text":"relaxed_gcd(x::T, y::T; tol::T = T(1e-6)) where {T}\n\nWe define two real numbers x and y to be tau-comensurable if, for some tau  0 there exists a continued fractions convergent p_k div q_k such that\n\n    left q_k x - p_k y right le tau\n\n\n\n\n\n","category":"function"},{"location":"booklet/#A-Primer-on-Submodularity","page":"Booklet","title":"A Primer on Submodularity","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"A set function f  2^S to mathbbR is said to be submodular if","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"f(X cup Y) + f(X cap Y) le f(X) + f(Y) forall X Y subset S","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"holds.","category":"page"},{"location":"booklet/#Quadratization","page":"Booklet","title":"Quadratization","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"In order to successfully achieve a QUBO formulation, sometimes it is needed to quadratize the resulting PBF, i.e., reduce its degree until reaching the quadratic case. There are many quadratization methods available, and ToQUBO implements a few of them.","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.PBO.quadratize!","category":"page"},{"location":"booklet/#ToQUBO.PBO.quadratize!","page":"Booklet","title":"ToQUBO.PBO.quadratize!","text":"quadratize!(aux::Function, f::PBF{S, T}, ::Quadratization{Q}) where {S,T,Q}\n\nQuadratizes a given PBF in-place, i.e. applies a mapping Q  mathscrF^k to mathscrF^2.\n\naux(::Nothing)::S\naux(::Integer)::Vector{S}\n\n\n\n\n\n","category":"function"},{"location":"booklet/#Virtual-Mapping","page":"Booklet","title":"Virtual Mapping","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"During reformulation, ToQUBO holds two distinct models, namely the Source Model and the Target Model. The source model is a generic MOI model restricted to the supported constraints. The target one is on the QUBO form used during the solving process. Both lie within a Virtual Model, which provides the necessary API integration and keeps all variable and constraint mapping tied together.","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"This is done in a transparent fashion for both agents since the user will mostly interact with the presented model, and the solvers will only access the generated one.","category":"page"},{"location":"booklet/#Virtual-Variables","page":"Booklet","title":"Virtual Variables","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"Every virtual model stores a collection of virtual variables, intended to provide a link between those in the source and those to be created in the target model. Each virtual variable stores enconding information for later expansion and evaluation.","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.VirtualVariable\nToQUBO.encode!","category":"page"},{"location":"booklet/#ToQUBO.VirtualVariable","page":"Booklet","title":"ToQUBO.VirtualVariable","text":"Variable Expansion methods:\n\n- Linear\n- Unary\n- Binary\n- One Hot\n- Domain Wall\n\nReferences:\n\n[1] Chancellor, N. (2019). Domain wall encoding of discrete variables for quantum annealing and QAOA. Quantum Science and Technology, 4(4), 045004. {doi}\n\n\n\n\n\n","category":"type"},{"location":"booklet/#ToQUBO.encode!","page":"Booklet","title":"ToQUBO.encode!","text":"encode!(model::VirtualModel{T}, v::VirtualVariable{T}) where {T}\n\nMaps newly created virtual variable v within the virtual model structure. It follows these steps:\n\nMaps v's source to it in the model's source mapping.\nFor every one of v's targets, maps it to itself and adds a binary constraint to it.\nAdds v to the end of the model's varvec.  \n\n\n\n\n\n","category":"function"},{"location":"booklet/#Variable-Encoding","page":"Booklet","title":"Variable Encoding","text":"","category":"section"},{"location":"booklet/#Linear-Encoding-Methods","page":"Booklet","title":"Linear Encoding Methods","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.LinearEncoding\nToQUBO.Binary\nToQUBO.Unary\nToQUBO.Arithmetic\nToQUBO.OneHot","category":"page"},{"location":"booklet/#ToQUBO.LinearEncoding","page":"Booklet","title":"ToQUBO.LinearEncoding","text":"LinearEncoding\n\nEvery linear encoding xi is of the form\n\nxi(mathbfy) = alpha + sum_i = 1^n gamma_i y_i\n\n\n\n\n\n","category":"type"},{"location":"booklet/#ToQUBO.Binary","page":"Booklet","title":"ToQUBO.Binary","text":"Binary\n\nBinary Expansion within the closed interval alpha beta.\n\nFor a given variable x in alpha beta we approximate it by\n\nx approx alpha + frac(beta - alpha)2^n - 1 sum_i=0^n-1 2^i y_i\n\nwhere n is the number of bits and y_i in mathbbB.\n\n\n\n\n\n","category":"type"},{"location":"booklet/#ToQUBO.Unary","page":"Booklet","title":"ToQUBO.Unary","text":"Unary()\n\nLet x in a b subset mathbbZ n = b - a mathbfy in mathbbB^n.\n\nx approx xi(mathbfy) = a + sum_j = 1^b - a y_j\n\n\n\n\n\n","category":"type"},{"location":"booklet/#ToQUBO.Arithmetic","page":"Booklet","title":"ToQUBO.Arithmetic","text":"Arithmetic\n\n\n\n\n\n","category":"type"},{"location":"booklet/#ToQUBO.OneHot","page":"Booklet","title":"ToQUBO.OneHot","text":"OneHot()\n\nThe one-hot encoding is a linear technique used to represent a variable x in leftlbracegamma_jrightrbrace_j in leftnright.\n\nThe encoding function is combined with a constraint assuring that only one and exactly one of the expansion's variables y_j is activated at a time.\n\nbeginarrayrl\nx = xi(mathbfy) =   sum_j = 1^n gamma_j y_j \n        mathrmst  sum_j = 1^n y_j = 1\nendarray\n\n\n\n\n\n","category":"type"},{"location":"booklet/#Sequential-Encoding-Methods","page":"Booklet","title":"Sequential Encoding Methods","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.SequentialEncoding\nToQUBO.DomainWall","category":"page"},{"location":"booklet/#ToQUBO.DomainWall","page":"Booklet","title":"ToQUBO.DomainWall","text":"DomainWall()\n\nThe Domain Wall[Chancellor2019] encoding method is a sequential approach that requires only n - 1 bits to represent n distinct values.\n\ntable: Encoding Analysis\n bits linear quadratic Delta\nDomain Wall n - 1 n  O(n)\n\n[Chancellor2019]: Nicholas Chancellor, Domain wall encoding of discrete variables for quantum annealing and QAOA, Quantum Science Technology 4, 2019.\n\n\n\n\n\n","category":"type"},{"location":"booklet/#Bounded-Coefficients","page":"Booklet","title":"Bounded Coefficients","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.Bounded","category":"page"},{"location":"booklet/#ToQUBO.Bounded","page":"Booklet","title":"ToQUBO.Bounded","text":"Bounded{Binary,T}(μ::T) where {T}\n\nLet x in a b subset mathbbZ and n = b - a.\n\nFirst,\n\nbeginalign*\n         2^k - 1  le mu \nimplies k          =   leftlfloorlog_2 mu + 1 rightrfloor\nendalign*\n\nSince\n\nsum_j = 1^k 2^j - 1 = sum_j = 0^k - 1 2^j = 2^k - 1\n\nthen, for r in mathbbN\n\nn = 2^k - 1 + r times mu + epsilon implies r = leftlfloor fracn - 2^k + 1mu rightrfloor\n\nand\n\nepsilon = n - 2^k + 1 - r times mu\n\n\\gamma_{j} = \\left\\lbrace\\begin{array}{cl}     2^{j} & \\text{if } 1 \\le j \\le k   \\\n    \\mu   & \\text{if } k < j < r + k   \\\n    n - 2^k + 1 - r \\times \\mu & \\text{otherwise} \\end{array}\\right. ```\n\nBounded{Unary,T}(μ::T) where {T}\n\n\n\n\n\n","category":"type"},{"location":"booklet/#Virtual-Models","page":"Booklet","title":"Virtual Models","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.VirtualModel","category":"page"},{"location":"booklet/#ToQUBO.VirtualModel","page":"Booklet","title":"ToQUBO.VirtualModel","text":"VirtualModel{T}(optimizer::Union{Nothing, Type{<:MOI.AbstractOptimizer}} = nothing) where {T}\n\nThis Virtual Model links the final QUBO formulation to the original one, allowing variable value retrieving and other features.\n\n\n\n\n\n","category":"type"},{"location":"booklet/#Annealing-and-Sampling","page":"Booklet","title":"Annealing & Sampling","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO's main goal is to benefit from non-deterministic samplers, especially Quantum Adiabatic devices and other Annealing machines. A few MOI-compliant interfaces for annealers and samplers are bundled within ToQUBO via the Anneal.jl submodule and package prototype. Some of them are presented below.","category":"page"},{"location":"booklet/#Quantum-Annealing","page":"Booklet","title":"Quantum Annealing","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"Interfacing with D-Wave's quantum computers is one of the milestones we expect to achieve with this package. Like other proprietary optimization resources such as Gurobi and FICO® Xpress, this requires licensing and extra steps are needed to get access to it. In a first moment, for those willing to get started, the Simulated Annealing optimizer might be enough.","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"While in JuMP, run using Anneal and look for QuantumAnnealer.Optimizer.","category":"page"},{"location":"booklet/#Simulated-Annealing","page":"Booklet","title":"Simulated Annealing","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"Provided by D-Wave's open-source code libraries, this Simulated Annealing engine implements some of the features and configuration you would find using the Quantum API. Its adoption is recommended for basic usage, tests, and during early research steps due to its simplicity and ease of use. It does not implement the most advanced Simulated Annealing algorithm available but performs fairly well on small instances. Anneal.jl exports this interface as SimulatedAnnealer.Optimizer.","category":"page"},{"location":"booklet/#Random-Sampling","page":"Booklet","title":"Random Sampling","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"This sampler is implemented for test purposes and simply assigns 0 or 1 to each variable according to a given probability bias 0 le p le 1, which defaults to p = 05. After running the using Anneal command, RandomSampler.Optimizer will be available.","category":"page"},{"location":"booklet/#Exact-Solver-(Exaustive-Enumeration)","page":"Booklet","title":"Exact Solver (Exaustive Enumeration)","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"Also made to be used in tests, the ExactSolver.Optimizer interface runs through all possible state configurations, which implies in an exponential time complexity on the number of variables. Thus, only problems with no more than 20 variables should be provided.","category":"page"},{"location":"booklet/#MIQP-Solvers","page":"Booklet","title":"MIQP Solvers","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"The most accessible alternative to Annealers and Samplers are Mixed-Integer Quadratic Programming (MIQP) Solvers such as Gurobi and CPLEX. These are not intended to be of regular use alongside ToQUBO since reformulation usually makes things harder for these folks. Yet, there are still cases where they may be suitable for tests on small instances.","category":"page"},{"location":"booklet/#Custom-Error-Types","page":"Booklet","title":"Custom Error Types","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.QUBOError","category":"page"},{"location":"booklet/#ToQUBO.QUBOError","page":"Booklet","title":"ToQUBO.QUBOError","text":"QUBOError(msg::Union{Nothing, String})\n\nThis error indicates any failure during QUBO formulation\n\n\n\n\n\n","category":"type"},{"location":"assets/README/#Logo","page":"Logo","title":"Logo","text":"","category":"section"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"The ideia behind ToQUBO's logo comes from a wordplay in Portuguese and Spanish. The package's main purpose is to assemble QUBO Models, which sounds like cubo¹, the translation for cube.","category":"page"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"(Image: ToQUBO.jl)","category":"page"},{"location":"assets/README/#Colors","page":"Logo","title":"Colors","text":"","category":"section"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"The colors were chosen according to  Julia's Reference for logo graphics². Text color matches the innermost shape and renders fairly well in both light and dark background themes.","category":"page"},{"location":"assets/README/#Typography","page":"Logo","title":"Typography","text":"","category":"section"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"MADETYPE Sunflower³ Font was used. It was converted to a SVG path through the Google Font to Svg Path⁴ online tool.","category":"page"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"<a href=\"#1\">¹</a> IPA: [ˈkubʊ]","category":"page"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"<a href=\"#2\">²</a> github.com/JuliaLang/julia-logo-graphics","category":"page"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"<a href=\"#3\">³</a> Licensed by the authors for use in this project","category":"page"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"<a href=\"#4\">⁴</a> danmarshall.github.io/google-font-to-svg-path","category":"page"},{"location":"assets/README/#Web-Icon-[![ToQUBO.jl](favicon.ico)](/docs/src/assets)","page":"Logo","title":"Web Icon (Image: ToQUBO.jl)","text":"","category":"section"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"The icon used to decorate the documentation resembles an assembled version of the cube with its blue face making up the background.","category":"page"}]
}
