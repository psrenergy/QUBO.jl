var documenterSearchIndex = {"docs":
[{"location":"booklet/1-intro/#ToQUBO.jl-Booklet","page":"Introduction","title":"ToQUBO.jl Booklet","text":"","category":"section"},{"location":"booklet/1-intro/","page":"Introduction","title":"Introduction","text":"This booklet aims to gather the theoretical and practical details behind ToQUBO and provide documentation for project internals. The target audience includes, among others, advanced users and those willing to contribute to the project. The latter are advised to read the following sections, as they give a glimpse of the ideas employed up to now.","category":"page"},{"location":"booklet/1-intro/#Table-of-Contents","page":"Introduction","title":"Table of Contents","text":"","category":"section"},{"location":"booklet/1-intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"2-qubo.md\", \"3-pbo.md\", \"4-encoding.md\", \"5-virtual.md\", \"6-compiler.md\", \"7-solvers.md\", \"8-appendix.md\"]\nDepth = 2","category":"page"},{"location":"manual/3-results/#Gathering-Results","page":"Gathering Results","title":"Gathering Results","text":"","category":"section"},{"location":"manual/3-results/","page":"Gathering Results","title":"Gathering Results","text":"warning: Work in progress\nWe hope to write this part of the documentation soon. Please come back later!","category":"page"},{"location":"booklet/4-encoding/#Encoding-Methods","page":"Encoding","title":"Encoding Methods","text":"","category":"section"},{"location":"booklet/4-encoding/#Variable-Encoding","page":"Encoding","title":"Variable Encoding","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"As you should already know, QUBO models are comprised only of binary variables. So when we are reformulating general optimization problems, one important step is to encode variables into binary ones. ","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO currently implements 6 encoding techniques. Each method introduces a different number of variables, quadratic terms and linear terms. Also, they differ in the range of their coefficients(Delta).","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Encoding Binary Variables # Linear terms # Quadratic terms Delta\nBinary O(log  n) O(log  n) - O(n)\nUnary O(n) O(n) - O(1)\nOne-Hot O(n) O(n) O(n^2) O(n)\nDomain-Wall O(n) O(n) O(n) O(n)\nBounded-Coefficient O(n) O(n) - O(1)\nArithmetic Prog O(sqrtn) O(sqrtn) - O(sqrtn)","category":"page"},{"location":"booklet/4-encoding/#Linear-Encoding-Methods","page":"Encoding","title":"Linear Encoding Methods","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.Mirror","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.Mirror","page":"Encoding","title":"ToQUBO.Mirror","text":"Mirror\n\nMirrors binary variable x in mathbbB with a twin variable y in mathbbB.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.LinearEncoding\nToQUBO.Linear\nToQUBO.Binary\nToQUBO.Unary\nToQUBO.Arithmetic\nToQUBO.OneHot","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.LinearEncoding","page":"Encoding","title":"ToQUBO.LinearEncoding","text":"LinearEncoding\n\nEvery linear encoding xi is of the form\n\nxi(mathbfy) = alpha + sum_i = 1^n gamma_i y_i\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Linear","page":"Encoding","title":"ToQUBO.Linear","text":"Linear\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Binary","page":"Encoding","title":"ToQUBO.Binary","text":"Binary\n\nBinary Expansion within the closed interval alpha beta.\n\nFor a given variable x in alpha beta we approximate it by\n\nx approx alpha + frac(beta - alpha)2^n - 1 sum_i=0^n-1 2^i y_i\n\nwhere n is the number of bits and y_i in mathbbB.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Unary","page":"Encoding","title":"ToQUBO.Unary","text":"Unary()\n\nLet x in a b subset mathbbZ n = b - a mathbfy in mathbbB^n.\n\nx approx xi(mathbfy) = a + sum_j = 1^b - a y_j\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Arithmetic","page":"Encoding","title":"ToQUBO.Arithmetic","text":"Arithmetic\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.OneHot","page":"Encoding","title":"ToQUBO.OneHot","text":"OneHot()\n\nThe one-hot encoding is a linear technique used to represent a variable x in leftlbracegamma_jrightrbrace_j in leftnright.\n\nThe encoding function is combined with a constraint assuring that only one and exactly one of the expansion's variables y_j is activated at a time.\n\nbeginarrayrl\nx = xi(mathbfy) =   sum_j = 1^n gamma_j y_j \n        mathrmst  sum_j = 1^n y_j = 1\nendarray\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#Sequential-Encoding-Methods","page":"Encoding","title":"Sequential Encoding Methods","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.SequentialEncoding\nToQUBO.DomainWall","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.DomainWall","page":"Encoding","title":"ToQUBO.DomainWall","text":"DomainWall()\n\nThe Domain Wall[Chancellor2019] encoding method is a sequential approach that requires only n - 1 bits to represent n distinct values.\n\ntable: Encoding Analysis\n bits linear quadratic Delta\nDomain Wall n - 1 n  O(n)\n\n[Chancellor2019]: Nicholas Chancellor, Domain wall encoding of discrete variables for quantum annealing and QAOA, Quantum Science Technology 4, 2019.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#Bounded-Coefficients","page":"Encoding","title":"Bounded Coefficients","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.Bounded","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.Bounded","page":"Encoding","title":"ToQUBO.Bounded","text":"Bounded{Binary,T}(μ::T) where {T}\n\nLet x in a b subset mathbbZ and n = b - a.\n\nFirst,\n\nbeginalign*\n         2^k - 1  le mu \nimplies k          =   leftlfloorlog_2 mu + 1 rightrfloor\nendalign*\n\nSince\n\nsum_j = 1^k 2^j - 1 = sum_j = 0^k - 1 2^j = 2^k - 1\n\nthen, for r in mathbbN\n\nn = 2^k - 1 + r times mu + epsilon implies r = leftlfloor fracn - 2^k + 1mu rightrfloor\n\nand\n\nepsilon = n - 2^k + 1 - r times mu\n\n\\gamma_{j} = \\left\\lbrace\\begin{array}{cl}     2^{j} & \\text{if } 1 \\le j \\le k   \\\n    \\mu   & \\text{if } k < j < r + k   \\\n    n - 2^k + 1 - r \\times \\mu & \\text{otherwise} \\end{array}\\right. ```\n\nBounded{Unary,T}(μ::T) where {T}\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#Constraint-Encoding","page":"Encoding","title":"Constraint Encoding","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"As you should already know, a QUBO model is unconstrained. So when ToQUBO is reformulating a problem, it needs to encode all constraints into the objective function loosing as little information as possible.","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"As constraints are introduced into the objective function, we need to make sure that they won't be violated. In order to do that, ToQUBO multiplies the encoded constraint by a large penalty rho, so that any violation would result in an infeasible solution to the problem.","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Sometimes, moving a constraint to the objective fuction might introduce higher-order terms (degree > 2). If that is the case, ToQUBO needs to reduce it back to a quadratic function. ","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"As of today, ToQUBO provides encoding for the following constraints:","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.toqubo_constraint","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.toqubo_constraint","page":"Encoding","title":"ToQUBO.toqubo_constraint","text":"toqubo_constraint\n\nReturns the pseudo-boolean function associated to a given constraint from the source model.\n\n\n\n\n\n","category":"function"},{"location":"manual/4-settings/#Compiler-Settings","page":"Compiler Settings","title":"Compiler Settings","text":"","category":"section"},{"location":"manual/4-settings/#Working-with-solver-architectures","page":"Compiler Settings","title":"Working with solver architectures","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.Architecture","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.Architecture","page":"Compiler Settings","title":"ToQUBO.Attributes.Architecture","text":"Architecture()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.AbstractArchitecture\nToQUBO.GenericArchitecture","category":"page"},{"location":"manual/4-settings/#ToQUBO.AbstractArchitecture","page":"Compiler Settings","title":"ToQUBO.AbstractArchitecture","text":"AbstractArchitecture\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Quadratization","page":"Compiler Settings","title":"Quadratization","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.Quadratize\nToQUBO.Attributes.QuadratizationMethod\nToQUBO.Attributes.StableQuadratization","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.Quadratize","page":"Compiler Settings","title":"ToQUBO.Attributes.Quadratize","text":"Quadratize()\n\nBoolean flag to conditionally perform the quadratization step. Is automatically set by the compiler when high-order functions are generated.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.QuadratizationMethod","page":"Compiler Settings","title":"ToQUBO.Attributes.QuadratizationMethod","text":"QuadratizationMethod()\n\nDefines which quadratization method to use. Available options are defined in the PBO submodule.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.StableQuadratization","page":"Compiler Settings","title":"ToQUBO.Attributes.StableQuadratization","text":"StableQuadratization()\n\nWhen set, this boolean flag enables stable quadratization methods, thus yielding predictable results. This is intended to be used during tests or other situations where deterministic output is desired. On the other hand, usage in production is not recommended since it requires increased memory and processing resources.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Variable-and-Constraint-Encoding","page":"Compiler Settings","title":"Variable & Constraint Encoding","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.VariableEncodingBits\nToQUBO.Attributes.DefaultVariableEncodingBits\nToQUBO.Attributes.VariableEncodingATol\nToQUBO.Attributes.DefaultVariableEncodingATol\nToQUBO.Attributes.VariableEncodingMethod\nToQUBO.Attributes.DefaultVariableEncodingMethod\nToQUBO.Attributes.VariableEncodingPenalty\nToQUBO.Attributes.ConstraintEncodingPenalty","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingBits","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingBits","text":"VariableEncodingBits()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.DefaultVariableEncodingBits","page":"Compiler Settings","title":"ToQUBO.Attributes.DefaultVariableEncodingBits","text":"DefaultVariableEncodingBits()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingATol","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingATol","text":"VariableEncodingATol()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.DefaultVariableEncodingATol","page":"Compiler Settings","title":"ToQUBO.Attributes.DefaultVariableEncodingATol","text":"DefaultVariableEncodingATol()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingMethod","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingMethod","text":"VariableEncodingMethod()\n\nAvailable methods are:\n\nBinary (default)\nUnary\nArithmetic\nOneHot\nDomainWall\nBounded\n\nThe Binary, Unary and Arithmetic encodings can have their expansion coefficients bounded by parametrizing the Bounded encoding.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.DefaultVariableEncodingMethod","page":"Compiler Settings","title":"ToQUBO.Attributes.DefaultVariableEncodingMethod","text":"DefaultVariableEncodingMethod()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingPenalty","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingPenalty","text":"VariableEncodingPenalty()\n\nAllows the user to set and retrieve the coefficients used for encoding variables when additional constraints are involved.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.ConstraintEncodingPenalty","page":"Compiler Settings","title":"ToQUBO.Attributes.ConstraintEncodingPenalty","text":"ConstraintEncodingPenalty()\n\nAllows the user to set and retrieve the coefficients used for encoding constraints.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Discretization","page":"Compiler Settings","title":"Discretization","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.Discretize","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.Discretize","page":"Compiler Settings","title":"ToQUBO.Attributes.Discretize","text":"Discretize()\n\nWhen set, this boolean flag guarantees that every coefficient in the final formulation is an integer.\n\n\n\n\n\n","category":"type"},{"location":"examples/prime_factorization/#Prime-Factorization","page":"Prime Factorization","title":"Prime Factorization","text":"","category":"section"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"A central problem in Number Theory and cryptography is to factor R in mathbbN, which is known to be the product of two distinct prime numbers p q in mathbbN. Shor's Algorithm, designed to address such task is often regarded as one of the major theoretical landmarks in Quantum Computing, being responsible for driving increasingly greater interest to the area.","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"A naïve approach to model this problem can be stated as a quadratically-constrained integer program:","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"beginarrayrl\ntextst  p times q = R \n             p q ge 0     \n             p q in mathbbZ\nendarray","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"From the definition and the basics of number theory, we are able to retrieve a few assumptions about the problem's variables:","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"p and q are bounded to the interval left1 Rright\nMoreover, it is fine to assume 1  p le sqrtR le q le R div 2.","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal\n\nfunction factor(R::Integer; optimizer = DWaveNeal.Optimizer)\n    return factor(identity, R; optimizer)\nend\n\nfunction factor(config!::Function, R::Integer; optimizer = DWaveNeal.Optimizer)\n    model = Model(() -> ToQUBO.Optimizer(optimizer))\n\n    @variable(model,  1 <= p <= √R, Int)\n    @variable(model, √R <= q <= R ÷ 2, Int)\n\n    @constraint(model, p * q == R)\n\n    config!(model)\n\n    optimize!(model)\n\n    p = round(Int, value(model[:p]))\n    q = round(Int, value(model[:q]))\n\n    return (p, q)\nend","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"p, q = factor(15) do model\n    set_optimizer_attribute(model, \"num_reads\", 1_000)\n    set_optimizer_attribute(model, \"num_sweeps\", 2_000)\nend\n\nprint(\"$p, $q\")","category":"page"},{"location":"booklet/3-pbo/#Pseudo-Boolean-Optimization","page":"PBO","title":"Pseudo-Boolean Optimization","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"Internally, problems are represented through a Pseudo-Boolean Optimization (PBO) framework. The main goal is to represent a given problem using a Pseudo-Boolean Function (PBF) since there is an immediate correspondence between optimization over quadratic PBFs and the QUBO formalism.","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"ToQUBO.PBO.PseudoBooleanFunction","category":"page"},{"location":"booklet/3-pbo/#ToQUBO.PBO.PseudoBooleanFunction","page":"PBO","title":"ToQUBO.PBO.PseudoBooleanFunction","text":"PseudoBooleanFunction{V,T}(Ω::Dict{Union{Set{V},Nothing},T}) where {V,T}\n\nA Pseudo-Boolean Function[Boros2002] f in mathscrF over some field mathbbT takes the form\n\nf(mathbfx) = sum_omega in Omegaleftfright c_omega prod_j in omega x_j\n\nwhere each Omegaleftfright is the multi-linear representation of f as a set of terms. Each term is given by a unique set of indices omega subseteq mathbbS related to some coefficient c_omega in mathbbT. We say that omega in Omegaleftfright iff c_omega neq 0. Variables x_j are boolean, thus f  mathbbB^n to mathbbT.\n\n[Boros2002]: Endre Boros, Peter L. Hammer, Pseudo-Boolean optimization, Discrete Applied Mathematics, 2002 {doi}\n\n\n\n\n\n","category":"type"},{"location":"booklet/3-pbo/#Quadratization","page":"PBO","title":"Quadratization","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"In order to successfully achieve a QUBO formulation, sometimes it is needed to quadratize the resulting PBF, i.e., reduce its degree until reaching the quadratic case. ","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"A quadratization is a mapping mathcalQ mathscrF to mathscrF^2 such that","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"forall f in mathscrF forall x in 0 1^n min_y mathcalQleftlbracefrightrbrace(x y) = f(x)\n","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"There are many quadratization methods available[Dattani2019], and ToQUBO implements two of them for now. However, using Julia's multiple dispatch paradigm, it's possible to extend the quadratization method coverage with your own algorithms.","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"ToQUBO.PBO.quadratize!","category":"page"},{"location":"booklet/3-pbo/#ToQUBO.PBO.quadratize!","page":"PBO","title":"ToQUBO.PBO.quadratize!","text":"quadratize!(aux::Function, f::PBF{S, T}, ::Quadratization{Q}) where {S,T,Q}\n\nQuadratizes a given PBF in-place, i.e. applies a mapping Q  mathscrF^k to mathscrF^2.\n\naux(::Nothing)::S\naux(::Integer)::Vector{S}\n\n\n\n\n\n","category":"function"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"[Dattani2019]: Nikesh S. Dattani, Quadratization in discrete optimization and quantum mechanics, ArXiv, 2019 {doi}","category":"page"},{"location":"booklet/3-pbo/#Implemented-Quadratization-Techniques","page":"PBO","title":"Implemented Quadratization Techniques","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"Currently, ToQUBO has two reduction algorithms, one for negative and another for positive terms.","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"ToQUBO.PBO.NTR_KZFD\nToQUBO.PBO.PTR_BG","category":"page"},{"location":"booklet/3-pbo/#ToQUBO.PBO.NTR_KZFD","page":"PBO","title":"ToQUBO.PBO.NTR_KZFD","text":"Quadratization{NTR_KZFD}(stable::Bool = false)\n\nNTR-KZFD (Kolmogorov & Zabih, 2004; Freedman & Drineas, 2005)\n\ninfo: Info\nIntroduces one new variable and no non-submodular terms.\n\n\n\n\n\n","category":"type"},{"location":"booklet/3-pbo/#ToQUBO.PBO.PTR_BG","page":"PBO","title":"ToQUBO.PBO.PTR_BG","text":"Quadratization{PTR_BG}(stable::Bool = false)\n\nPTR-BG (Boros & Gruber, 2014)\n\ninfo: Info\nIntroduces k - 2 new variables and k - 1 non-submodular terms.\n\n\n\n\n\n","category":"type"},{"location":"booklet/3-pbo/#A-Primer-on-Submodularity","page":"PBO","title":"A Primer on Submodularity","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"A set function f  2^S to mathbbR is said to be submodular if","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"f(X cup Y) + f(X cap Y) le f(X) + f(Y) forall X Y subset S","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"holds.","category":"page"},{"location":"booklet/6-compiler/#The-Compiler","page":"The Compiler","title":"The Compiler","text":"","category":"section"},{"location":"booklet/6-compiler/","page":"The Compiler","title":"The Compiler","text":"warning: Work in progress\nWe hope to write this part of the documentation soon. Please come back later!","category":"page"},{"location":"booklet/6-compiler/#Compilation-Steps","page":"The Compiler","title":"Compilation Steps","text":"","category":"section"},{"location":"booklet/6-compiler/","page":"The Compiler","title":"The Compiler","text":"ToQUBO.toqubo_sense!\nToQUBO.toqubo_variables!\nToQUBO.toqubo_constraint\nToQUBO.toqubo_constraints!\nToQUBO.toqubo_objective!\nToQUBO.toqubo_penalties!\nToQUBO.toqubo_parse!\nToQUBO.toqubo_build!","category":"page"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_sense!","page":"The Compiler","title":"ToQUBO.toqubo_sense!","text":"toqubo_sense!(model::VirtualModel, ::AbstractArchitecture) where {T}\n\nCopies MOI.ObjectiveSense from model.source_model to model.target_model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_variables!","page":"The Compiler","title":"ToQUBO.toqubo_variables!","text":"toqubo_variables!(model::VirtualModel{T}) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_constraints!","page":"The Compiler","title":"ToQUBO.toqubo_constraints!","text":"toqubo_constraints!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_objective!","page":"The Compiler","title":"ToQUBO.toqubo_objective!","text":"toqubo_objective!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_penalties!","page":"The Compiler","title":"ToQUBO.toqubo_penalties!","text":"toqubo_penalties!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_parse!","page":"The Compiler","title":"ToQUBO.toqubo_parse!","text":"toqubo_parse!(\n    model::VirtualModel{T},\n    g::PBO.PBF{VI,T},\n    f::MOI.AbstractFunction,\n    arch::AbstractArchitectur\n) where {T}\n\nParses the given MOI function f into PBF g.\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_build!","page":"The Compiler","title":"ToQUBO.toqubo_build!","text":"toqubo_build!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"manual/1-start/#Manual","page":"Getting Started","title":"Manual","text":"","category":"section"},{"location":"manual/1-start/#Quick-Start-Guide","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"manual/1-start/","page":"Getting Started","title":"Getting Started","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal # <- Your favourite Annealer/Sampler/Solver here\n\nmodel = Model(() -> ToQUBO.Optimizer(DWaveNeal.Optimizer))\n\n@variable(model, x[1:3], Bin)\n\n@objective(model, Max, 1.0 * x[1] + 2.0 * x[2] + 3.0 * x[3])\n\n@constraint(model, 0.3 * x[1] + 0.5 * x[2] + 1.0 * x[3] <= 1.6)\n\noptimize!(model)\n\nsolution_summary(model)","category":"page"},{"location":"manual/1-start/#Table-of-Contents","page":"Getting Started","title":"Table of Contents","text":"","category":"section"},{"location":"manual/1-start/","page":"Getting Started","title":"Getting Started","text":"Pages = [\"2-model.md\", \"3-results.md\", \"4-settings.md\"]\nDepth = 2","category":"page"},{"location":"booklet/2-qubo/#QUBO","page":"QUBO","title":"QUBO","text":"","category":"section"},{"location":"booklet/2-qubo/#Definition","page":"QUBO","title":"Definition","text":"","category":"section"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"QUBO stands for Quadratic Unconstrained Binary Optimization. ","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"So every QUBO model has the following characteristics:","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"Its objective function is at most quadratic\nThere are no constraints\nAll variables are binary (0 or 1)","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"We can represent a QUBO as follows.","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"beginarrayrl\n   min           mathbfx Qmathbfx \n   mathrmst  mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"booklet/2-qubo/#OK,-but-why-QUBO?","page":"QUBO","title":"OK, but why QUBO?","text":"","category":"section"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"QUBOs are suited for representing non-convex global optimization problems. With that said, the significant advances in computing systems and algorithms specialized for sampling QUBOs have contributed to their popularity.","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"Some of the paradigms that stand out for running QUBOs are quantum gate-based optimization algorithms (QAOA and VQE), quantum annealers and hardware-accelerated platforms (Coherent Ising Machines and Simulated Bifurcation Machines).","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"(Image: D-Wave Washington 1000Q)","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"ToQUBO.isqubo\nToQUBO.toqubo\nToQUBO.toqubo!","category":"page"},{"location":"booklet/2-qubo/#ToQUBO.isqubo","page":"QUBO","title":"ToQUBO.isqubo","text":"isqubo(model::MOI.ModelLike)\n\nTells if a given model is ready to be interpreted as a QUBO model.\n\nFor it to be true, a few conditions must be met:\n\nAll variables must be binary (MOI.VariableIndex ∈ MOI.ZeroOne)\nNo other constraints are allowed\nThe objective function must be of type MOI.ScalarQuadraticFunction, MOI.ScalarAffineFunction or MOI.VariableIndex\nThe objective sense must be either MOI.MIN_SENSE or MOI.MAX_SENSE\n\n\n\n\n\n","category":"function"},{"location":"booklet/2-qubo/#ToQUBO.toqubo","page":"QUBO","title":"ToQUBO.toqubo","text":"toqubo(\n    [T=Float64,]\n    source::MOI.ModelLike,\n    ::AbstractArchitecture;\n    optimizer::Union{Nothing, Type{<:MOI.AbstractOptimizer}} = nothing\n)\n\nLow-level interface to create a ::VirtualModel{T} from ::MOI.ModelLike instance. If provided, an ::MOI.AbstractOptimizer is attached to the model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/2-qubo/#ToQUBO.toqubo!","page":"QUBO","title":"ToQUBO.toqubo!","text":"toqubo!(model::VirtualModel{T}, ::AbstractArchitecture) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/8-appendix/#Appendix","page":"Appendix","title":"Appendix","text":"","category":"section"},{"location":"booklet/8-appendix/#ToQUBO.jl's-Assets","page":"Appendix","title":"ToQUBO.jl's Assets","text":"","category":"section"},{"location":"booklet/8-appendix/#Logo","page":"Appendix","title":"Logo","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The ideia behind ToQUBO.jl's logo comes from a wordplay in Portuguese and Spanish. The package's main purpose is to assemble QUBO Models, which sounds like cubo[1], the translation for cube.","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"(Image: ToQUBO.jl Logo)","category":"page"},{"location":"booklet/8-appendix/#Colors","page":"Appendix","title":"Colors","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The colors were picked according to  Julia's Reference for logo graphics[2]. Text color matches the innermost shape and renders fairly well in both light and dark background themes.","category":"page"},{"location":"booklet/8-appendix/#Typography","page":"Appendix","title":"Typography","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The MADETYPE Sunflower[3] font was chosen. It was converted to a SVG path using the Google Font to Svg Path[4] online tool.","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[1]: IPA: [ˈkubʊ]","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[2]: github.com/JuliaLang/julia-logo-graphics","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[3]: Licensed by the authors for use in this project","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[4]: danmarshall.github.io/google-font-to-svg-path","category":"page"},{"location":"booklet/8-appendix/#Web-Icon-[![ToQUBO.jl-Icon](../../assets/favicon.ico)]()","page":"Appendix","title":"Web Icon (Image: ToQUBO.jl Icon)","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The icon used to decorate the documentation resembles an assembled version of the cube with its blue face making up the background.","category":"page"},{"location":"booklet/7-solvers/#QUBO-Solvers","page":"Solvers","title":"QUBO Solvers","text":"","category":"section"},{"location":"booklet/7-solvers/#Solvers,-Annealers-and-Samplers","page":"Solvers","title":"Solvers, Annealers & Samplers","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"ToQUBO.jl's main goal is to make use of parameterized stochastic optimization solvers, particularly those relying on non-conventional hardware such as Quantum Annealing and other Ising Machines. A few MOI-compliant interfaces for annealers and samplers are bundled within ToQUBO.jl via the Anneal.jl companion package. Some of them are presented below.","category":"page"},{"location":"booklet/7-solvers/#Simulated-Annealing","page":"Solvers","title":"Simulated Annealing","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"Provided by D-Wave's open-source code libraries, this Simulated Annealing engine implements some of the features and configurations you would find using the Quantum API. Its adoption is recommended for basic usage, tests, and research due to its robustness, simplicity and ease of use. The DWaveNeal.jl package uses Anneal.jl to deliver an interface to this sampler.","category":"page"},{"location":"booklet/7-solvers/#Quantum-Annealing","page":"Solvers","title":"Quantum Annealing","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"Interfacing with D-Wave's quantum annealer is one of the milestones we expect to achieve with this package. Like other proprietary optimization resources such as Gurobi, FICO® Xpress and IBM® CPLEX®, this requires licensing and extra steps are needed to get an access token. In a first moment, for those willing to get started, the DWaveNeal.jl optimizer might be enough to learn the ropes.","category":"page"},{"location":"booklet/7-solvers/#Random-Sampling","page":"Solvers","title":"Random Sampling","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"This sampler is implemented for test purposes and simply assigns 0 or 1 to each variable according to a given probability bias 0 le p le 1, which defaults to p = 05. After running the using Anneal command, RandomSampler.Optimizer will be available.","category":"page"},{"location":"booklet/7-solvers/#Exact-Solver-(Exhaustive-Enumeration)","page":"Solvers","title":"Exact Solver (Exhaustive Enumeration)","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"Also made to be used in tests, the ExactSolver.Optimizer interface runs through all possible state configurations, which implies in an exponential time complexity on the number of variables. Thus, only problems with at most approxeq 20 variables should be provided since visiting 2^20 approxeq 10^6 states can already take up to a few seconds.","category":"page"},{"location":"booklet/7-solvers/#Mixed-Integer-Quadratic-Programming","page":"Solvers","title":"Mixed-Integer Quadratic Programming","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"The most accessible alternative to the forementioned methods are Mixed-Integer Quadratic Programming (MIQP) solvers such as Gurobi, CPLEX, SCIP and BARON. These are not intended to be of regular use alongside ToQUBO.jl since providing a QUBO reformulation will usually make things harder for non-specialized solvers. Yet, there are still a few cases where they may be suitable, such as tests, benchmarks, or any other situation where global optimality is a must.","category":"page"},{"location":"manual/2-model/#Running-a-Model","page":"Running a Model","title":"Running a Model","text":"","category":"section"},{"location":"manual/2-model/","page":"Running a Model","title":"Running a Model","text":"warning: Work in progress\nWe hope to write this part of the documentation soon. Please come back later!","category":"page"},{"location":"booklet/5-virtual/#Virtual-Mapping","page":"Virtual Mapping","title":"Virtual Mapping","text":"","category":"section"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"During reformulation, ToQUBO holds two distinct models, namely the Source Model and the Target Model. The source model is a generic MOI model restricted to the supported constraints. The target one is on the QUBO form used during the solving process. Both lie within a Virtual Model, which provides the necessary API integration and keeps all variable and constraint mapping tied together.","category":"page"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"<script type=\"text/tikz\">\n  \\begin{tikzpicture}\n    \\draw (0,0) circle (1in);\n  \\end{tikzpicture}\n</script>","category":"page"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"This is done in a transparent fashion for both agents since the user will mostly interact with the presented model, and the solvers will only access the generated one.","category":"page"},{"location":"booklet/5-virtual/#Virtual-Model","page":"Virtual Mapping","title":"Virtual Model","text":"","category":"section"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"ToQUBO.VirtualModel","category":"page"},{"location":"booklet/5-virtual/#ToQUBO.VirtualModel","page":"Virtual Mapping","title":"ToQUBO.VirtualModel","text":"VirtualModel{T}(optimizer::Union{Nothing, Type{<:MOI.AbstractOptimizer}} = nothing) where {T}\n\nThis Virtual Model links the final QUBO formulation to the original one, allowing variable value retrieving and other features.\n\n\n\n\n\n","category":"type"},{"location":"booklet/5-virtual/#Virtual-Variables","page":"Virtual Mapping","title":"Virtual Variables","text":"","category":"section"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"Every virtual model stores a collection of virtual variables, intended to provide a link between those in the source and those to be created in the target model. Each virtual variable stores encoding information for later expansion and evaluation.","category":"page"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"ToQUBO.VirtualVariable\nToQUBO.encode!","category":"page"},{"location":"booklet/5-virtual/#ToQUBO.VirtualVariable","page":"Virtual Mapping","title":"ToQUBO.VirtualVariable","text":"Variable Expansion methods:\n\n- Linear\n- Unary\n- Binary\n- One Hot\n- Domain Wall\n\nReferences:\n\n[1] Chancellor, N. (2019). Domain wall encoding of discrete variables for quantum annealing and QAOA. Quantum Science and Technology, 4(4), 045004. {doi}\n\n\n\n\n\n","category":"type"},{"location":"booklet/5-virtual/#ToQUBO.encode!","page":"Virtual Mapping","title":"ToQUBO.encode!","text":"encode!(model::VirtualModel{T}, v::VirtualVariable{T}) where {T}\n\nMaps newly created virtual variable v within the virtual model structure. It follows these steps:\n\nMaps v's source to it in the model's source mapping.\nFor every one of v's targets, maps it to itself and adds a binary constraint to it.\nAdds v to the end of the model's varvec.  \n\n\n\n\n\n","category":"function"},{"location":"#ToQUBO.jl-Documentation","page":"Home","title":"ToQUBO.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ToQUBO.jl is a Julia Package intended to automatically translate models written in JuMP, into the QUBO mathematical optimization framework.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"ToQUBO\")","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal\n\nmodel = Model(() -> ToQUBO.Optimizer(DWaveNeal.Optimizer))\n\n@variable(model, x[1:3], Bin)\n@objective(model, Max, 1.0*x[1] + 2.0*x[2] + 3.0*x[3])\n@constraint(model, 0.3*x[1] + 0.5*x[2] + 1.0*x[3] <= 1.6)\n\noptimize!(model)\n\nsolution_summary(model)","category":"page"},{"location":"#Citing-ToQUBO.jl","page":"Home","title":"Citing ToQUBO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ToQUBO.jl in your work, we kindly ask you to include the following citation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{toqubo:2023,\n  author       = {Pedro Maciel Xavier and Pedro Ripper and Tiago Andrade and Joaquim Dias Garcia and David E. Bernal Neira},\n  title        = {{ToQUBO.jl}},\n  month        = {feb},\n  year         = {2023},\n  publisher    = {Zenodo},\n  version      = {v0.1.5},\n  doi          = {10.5281/zenodo.7644291},\n  url          = {https://doi.org/10.5281/zenodo.7644291}\n}","category":"page"},{"location":"examples/knapsack/#Knapsack","page":"Knapsack","title":"Knapsack","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"We start with some instances of the discrete Knapsack Problem whose standard formulation is","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"beginarrayr l\n    max         mathbfc mathbfx \n    textst  mathbfw mathbfx le C \n                mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"examples/knapsack/#MathOptInterface","page":"Knapsack","title":"MathOptInterface","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"Using MOI directly to build a simple model is pretty straightforward. All that one has to do is to use MOI.instantiate and define the model as usual.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"import MathOptInterface as MOI\nconst MOIU = MOI.Utilities\n\nusing ToQUBO\nusing DWaveNeal # <- Your favourite Annealer / Sampler / Solver here\n\n# Example from https://jump.dev/MathOptInterface.jl/stable/tutorials/example/\n\n# Virtual QUBO Model\nmodel = MOI.instantiate(\n   () -> ToQUBO.Optimizer(DWaveNeal.Optimizer),\n   with_bridge_type = Float64,\n)\n\nn = 3;\nc = [1.0, 2.0, 3.0]\nw = [0.3, 0.5, 1.0]\nC = 3.2;\n\nx = MOI.add_variables(model, n);\n\nfor xᵢ in x\n   MOI.add_constraint(model, xᵢ, MOI.ZeroOne())\nend\n\nMOI.set(model, MOI.ObjectiveSense(), MOI.MAX_SENSE)\n\nMOI.set(\n   model,\n   MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n   MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0),\n);\n\nMOI.add_constraint(\n   model,\n   MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(w, x), 0.0),\n   MOI.LessThan(C),\n);\n\nMOI.optimize!(model)\n\n# Collect Solution\nMOI.get.(model, MOI.VariablePrimal(), x)","category":"page"},{"location":"examples/knapsack/#JuMP-D-Wave-Examples","page":"Knapsack","title":"JuMP + D-Wave Examples","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"We may now fill a few more knapsacks using JuMP. We will generate uniform random costs mathbfc and weights mathbfw then set the knapsack's capacity C to be a fraction of the total available weight i.e. 80.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"This example was inspired by D-Wave's knapsack example repository.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using CSV\nusing DataFrames\nusing Random\n\n# Generate Data\nrng = MersenneTwister(1)\n\ndf = DataFrame(\n   :cost   => rand(rng, 1:100, 16),\n   :weight => rand(rng, 1:100, 16),\n)\n\nCSV.write(\"knapsack.csv\", df)","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using CSV\nusing DataFrames\n\ndf = CSV.read(\"knapsack.csv\", DataFrame)","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal # <- Your favourite Annealer/Sampler/Solver here\n\nmodel = Model(() -> ToQUBO.Optimizer(DWaveNeal.Optimizer))\n\nn = size(df, 1)\nc = collect(Float64, df[!, :cost])\nw = collect(Float64, df[!, :weight])\nC = round(0.8 * sum(w))\n\n@variable(model, x[1:n], Bin)\n@objective(model, Max, c' * x)\n@constraint(model, w' * x <= C)\n\noptimize!(model)\n\n# Add Results as a new column\ninsertcols!(df, 3, :select => map((ξ) -> (ξ > 0.0) ? \"Yes\" : \"No\", value.(x)))","category":"page"}]
}
