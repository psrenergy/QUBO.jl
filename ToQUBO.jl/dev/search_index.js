var documenterSearchIndex = {"docs":
[{"location":"booklet/1-intro/#ToQUBO.jl-Booklet","page":"Introduction","title":"ToQUBO.jl Booklet","text":"","category":"section"},{"location":"booklet/1-intro/","page":"Introduction","title":"Introduction","text":"This booklet aims to gather the theoretical and practical details behind ToQUBO and provide documentation for project internals. The target audience includes, among others, advanced users and those willing to contribute to the project. The latter are advised to read the following sections, as they give a glimpse of the ideas employed up to now.","category":"page"},{"location":"booklet/1-intro/#Table-of-Contents","page":"Introduction","title":"Table of Contents","text":"","category":"section"},{"location":"booklet/1-intro/","page":"Introduction","title":"Introduction","text":"Pages = [\"2-qubo.md\", \"3-pbo.md\", \"4-encoding.md\", \"5-virtual.md\", \"6-compiler.md\", \"7-solvers.md\", \"8-appendix.md\"]\nDepth = 2","category":"page"},{"location":"manual/3-results/#Gathering-Results","page":"Gathering Results","title":"Gathering Results","text":"","category":"section"},{"location":"manual/3-results/","page":"Gathering Results","title":"Gathering Results","text":"warning: Work in progress\nWe hope to write this part of the documentation soon. Please come back later!","category":"page"},{"location":"booklet/4-encoding/#Encoding-Methods","page":"Encoding","title":"Encoding Methods","text":"","category":"section"},{"location":"booklet/4-encoding/#Variables","page":"Encoding","title":"Variables","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"As you may already know, QUBO models are comprised only of binary variables. So when we are reformulating general optimization problems, one important step is to encode variables into binary ones. ","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO currently implements 6 encoding techniques. Each method introduces a different number of variables, quadratic terms and linear terms. Also, they differ in the magnitude of their coefficients Delta.","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Encoding Binary Variables # Linear terms # Quadratic terms Delta\nBinary O(log n) O(log n) - O(n)\nUnary O(n) O(n) - O(1)\nOne-Hot O(n) O(n) O(n^2) O(n)\nDomain-Wall O(n) O(n) O(n) O(n)\nBounded-Coefficient O(n) O(n) - O(1)\nArithmetic Prog O(sqrtn) O(sqrtn) - O(sqrtn)","category":"page"},{"location":"booklet/4-encoding/#Linear-Encoding","page":"Encoding","title":"Linear Encoding","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.Unary\nToQUBO.Binary\nToQUBO.Arithmetic\nToQUBO.OneHot","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.Unary","page":"Encoding","title":"ToQUBO.Unary","text":"Unary()\n\nInteger\n\nLet x in a b subset mathbbZ, n = b - a and mathbfy in mathbbB^n.\n\nxia b(mathbfy) = a + sum_j = 1^b - a y_j\n\nReal\n\nGiven n in mathbbN for x in a b subset mathbbR,\n\nxia b(mathbfy) = a + fracb - an sum_j = 1^n y_j\n\nEncoding error\n\nGiven tau  0, for the expected encoding error to be less than or equal to tau, at least\n\nn ge 1 + fracb - a4 tau\n\nbinary variables become necessary.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Binary","page":"Encoding","title":"ToQUBO.Binary","text":"Binary()\n\nInteger\n\nLet x in a b subset mathbbZ, n = leftlceil log_2(b - a) + 1 rightrceil and mathbfy in mathbbB^n.\n\nxia b(mathbfy) = a + left(b - a - 2^n - 1 + 1right) y_n + sum_j = 1^n - 1 2^j - 1 y_j\n\nReal\n\nGiven n in mathbbN for x in a b subset mathbbR,\n\nxia b(mathbfy) = a + fracb - a2^n - 1 sum_j = 1^n 2^j - 1 y_j\n\nEncoding error\n\nGiven tau  0, for the expected encoding error to be less than or equal to tau, at least\n\nn ge log_2 left1 + fracb - a4 tauright\n\nbinary variables become necessary.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.Arithmetic","page":"Encoding","title":"ToQUBO.Arithmetic","text":"Arithmetic()\n\nInteger\n\nLet x in a b subset mathbbZ, n = leftlceil frac12 sqrt1 + 8 (b - a) - frac12 rightrceil and mathbfy in mathbbB^n.\n\nxia b(mathbfy) = a + left( b - a - fracn (n - 1)2 right) y_n + sum_j = 1^n - 1 j y_j\n\nReal\n\nGiven n in mathbbN for x in a b subset mathbbR,\n\nxia b(mathbfy) = a + fracb - an (n + 1) sum_j = 1^n j y_j\n\nEncoding error\n\nGiven tau  0, for the expected encoding error to be less than or equal to tau, at least\n\nn ge frac12 left 1 + sqrt3 + frac(b - a)2 tau) right\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#ToQUBO.OneHot","page":"Encoding","title":"ToQUBO.OneHot","text":"OneHot()\n\nThe one-hot encoding is a linear technique used to represent a variable x in setgamma_j_j in n.\n\nThe associated encoding function is combined with a constraint assuring that only one and exactly one of the expansion's variables y_j is activated at a time.\n\nxisetgamma_j_j in n(mathbfy) = sum_j = 1^n gamma_j y_j textrmst sum_j = 1^n y_j = 1\n\nWhen a variable is encoded following this approach, a penalty term of the form\n\nrho left sum_j = 1^n y_j - 1 right^2\n\nis added to the objective function.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.Mirror","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.Mirror","page":"Encoding","title":"ToQUBO.Mirror","text":"Mirror()\n\nMirrors binary variable x in mathbbB with a twin variable y in mathbbB.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#Sequential-Encoding","page":"Encoding","title":"Sequential Encoding","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.DomainWall","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.DomainWall","page":"Encoding","title":"ToQUBO.DomainWall","text":"DomainWall()\n\nThe Domain Wall[Chancellor2019] encoding method is a sequential approach that requires n - 1 bits to represent n distinct values.\n\nxisetgamma_j_j in n(mathbfy) = sum_j = 1^n gamma_j (y_j - y_j + 1) textrmst sum_j = 1^n y_j oplus y_j + 1 = 1 y_1 = 1 y_n + 1 = 0\n\nwhere mathbfy in mathbbB^n + 1.\n\n[Chancellor2019]: Nicholas Chancellor, Domain wall encoding of discrete variables for quantum annealing and QAOA, Quantum Science Technology 4, 2019.\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#Bounded-Coefficients","page":"Encoding","title":"Bounded Coefficients","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.Bounded","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.Bounded","page":"Encoding","title":"ToQUBO.Bounded","text":"Bounded{E,T}(μ::T) where {E<:Encoding,T}\n\nThe bounded-coefficient encoding method[Karimi2019] consists in limiting the magnitude of the coefficients in the encoding expansion to a parameter mu.\n\n[Karimi2019]: Karimi, S. & Ronagh, P. Practical integer-to-binary mapping for quantum annealers. Quantum Inf Process 18, 94 (2019). {doi}\n\nThis can be applied to the Unary, Binary and Arithmetic encoding schemas, as discussed below.\n\nBounded{Unary,T}(μ::T) where {T}\n\nGiven mu  0, let x in a b subset mathbbZ and n = b - a.\n\nBounded{Binary,T}(μ::T) where {T}\n\nGiven mu  0, let x in a b subset mathbbZ and n = b - a.\n\nFirst,\n\nbeginalign*\n         2^k - 1  le mu \nimplies k          =   leftlfloorlog_2 mu + 1 rightrfloor\nendalign*\n\nSince\n\nsum_j = 1^k 2^j - 1 = sum_j = 0^k - 1 2^j = 2^k - 1\n\nthen, for r in mathbbN\n\nn = 2^k - 1 + r times mu + epsilon implies r = leftlfloor fracn - 2^k + 1mu rightrfloor\n\nand\n\nepsilon = n - 2^k + 1 - r times mu\n\nTherefore,\n\nxi_mua b(mathbfy) = sum_j = 1 gamma_j y_j\n\nwhere\n\ngamma_j = leftlbracebeginarraycl\n    2^j  textif  1 le j le k   \n    mu    textif  k  j  r + k   \n    n - 2^k + 1 - r times mu  textotherwise\nendarrayright\n\n\n\n\n\n","category":"type"},{"location":"booklet/4-encoding/#Encoding-Error","page":"Encoding","title":"Encoding Error","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Let setx_i_i in k be the collection of k evenly spaced samples from the discretization of an interval a b subseteq mathbbR.","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"The representation error for a given point x with respect to setx_i_i in k is","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"e_k(x) = min_i in k leftx - x_iright","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Assuming that x behaves as a uniformly distributed random variable, the expected absolute encoding error is","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"beginalign*\nmathbbElefte_k(x)right = frac1b - a int_a^b e_k(x) mathrmdx \n                              = frac14 fracb - ak - 1\nendalign*","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Thus, for encoding methods that rely on the regular division of an interval, it is possible to define the number of samples k necessary to limit the expected error according to an upper bound tau, that is,","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"mathbbElefte_k(x)right le tau implies k ge 1 + fracb - a4 tau","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"This allows the compiler to automatically infer the number of bits to allocate for an encoded variable given the tolerance factor.","category":"page"},{"location":"booklet/4-encoding/#Constraints","page":"Encoding","title":"Constraints","text":"","category":"section"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"A QUBO model is unconstrained. So when ToQUBO is reformulating a problem, it needs to encode all constraints into the objective function losing as little information as possible.","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"As constraints are introduced into the objective function, we need to make sure that they won't be violated. In order to do that, ToQUBO multiplies the encoded constraint by a large penalty rho, so that any violation would result in a sub-optimal solution to the problem.","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"Sometimes, the encoding process might introduce higher-order terms, demanding ToQUBO to reduce the offending polynomials back to a quadratic form. ","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"As of today, ToQUBO provides encoding for the following constraints:","category":"page"},{"location":"booklet/4-encoding/","page":"Encoding","title":"Encoding","text":"ToQUBO.toqubo_constraint","category":"page"},{"location":"booklet/4-encoding/#ToQUBO.toqubo_constraint","page":"Encoding","title":"ToQUBO.toqubo_constraint","text":"toqubo_constraint(\n    ::VirtualModel{T},\n    ::VI,\n    ::Union{\n        MOI.ZeroOne,\n        MOI.Integer,\n        MOI.Interval{T},\n        MOI.LessThan{T},\n        MOI.GreaterThan{T}\n    },\n    ::AbstractArchitecture\n) where {T}\n\nThis method skips bound constraints over variables.\n\n\n\n\n\ntoqubo_constraint(\n    model::VirtualModel{T}, \n    f::SAF{T}, \n    s::EQ{T}, \n    ::AbstractArchitecture\n) where {T}\n\nTurns constraints of the form\n\n\nbeginarrayrl\ntextst  mathbfamathbfx - b = 0\nendarray\n\n\ninto \n\n\nleftVert(mathbfx)rightVert_leftlbrace0rightrbrace = left(mathbfamathbfx - bright)^2\n\n\n\n\n\n\ntoqubo_constraint(\n    model::VirtualModel{T}, \n    f::SAF{T}, \n    s::LT{T}, \n    ::AbstractArchitecture\n) where {T}\n\nTurns constraints of the form\n\nbeginarrayrl\ntextst  mathbfamathbfx - b le 0\nendarray\n\ninto \n\nleftVert(mathbfx)rightVert_leftlbrace0rightrbrace = (mathbfamathbfx - b + z)^2\n\n\nby adding a slack variable z.\n\n\n\n\n\ntoqubo_constraint(\n    model::VirtualModel{T},\n    f::SQF{T},\n    s::EQ{T},\n    arch::AbstractArchitecture,\n) where {T}\n\nTurns constraints of the form\n\nbeginarrayrl\ntextst  mathbfxmathbfQmathbfx + mathbfamathbfx - b = 0\nendarray\n\ninto\n\nleftVert(mathbfx)rightVert_leftlbrace0rightrbrace = (mathbfxmathbfQmathbfx + mathbfamathbfx - b)^2\n\n\n\n\n\n\ntoqubo_constraint(\n    model::VirtualModel{T},\n    f::SQF{T},\n    s::LT{T},\n    arch::AbstractArchitecture,\n) where {T}\n\nTurns constraints of the form\n\nbeginarrayrl\ntextst  mathbfxmathbfQmathbfx + mathbfamathbfx - b leq 0\nendarray\n\ninto\n\nleftVert(mathbfx)rightVert_leftlbrace0rightrbrace = (mathbfxmathbfQmathbfx + mathbfamathbfx - b + z)^2\n\n\nby adding a slack variable z.\n\n\n\n\n\ntoqubo_constraint(\n    model::VirtualModel{T},\n    x::MOI.VectorOfVariables,\n    ::MOI.SOS1{T},\n    ::AbstractArchitecture,\n) where {T}\n\n\n\n\n\n","category":"function"},{"location":"manual/4-settings/#Compiler-Settings","page":"Compiler Settings","title":"Compiler Settings","text":"","category":"section"},{"location":"manual/4-settings/#Working-with-solver-architectures","page":"Compiler Settings","title":"Working with solver architectures","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.Architecture","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.Architecture","page":"Compiler Settings","title":"ToQUBO.Attributes.Architecture","text":"Architecture()\n\nSelects which solver architecture to use. Defaults to GenericArchitecture.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.AbstractArchitecture\nToQUBO.GenericArchitecture","category":"page"},{"location":"manual/4-settings/#ToQUBO.AbstractArchitecture","page":"Compiler Settings","title":"ToQUBO.AbstractArchitecture","text":"AbstractArchitecture\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.GenericArchitecture","page":"Compiler Settings","title":"ToQUBO.GenericArchitecture","text":"GenericArchitecture()\n\nThis type is used to reach fallback implementations for AbstractArchitecture and, therefore, should not have any methods directely related to it.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Quadratization","page":"Compiler Settings","title":"Quadratization","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.Quadratize\nToQUBO.Attributes.QuadratizationMethod\nToQUBO.Attributes.StableQuadratization","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.Quadratize","page":"Compiler Settings","title":"ToQUBO.Attributes.Quadratize","text":"Quadratize()\n\nBoolean flag to conditionally perform the quadratization step. Is automatically set by the compiler when high-order functions are generated.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.QuadratizationMethod","page":"Compiler Settings","title":"ToQUBO.Attributes.QuadratizationMethod","text":"QuadratizationMethod()\n\nDefines which quadratization method to use. Available options are defined in the PBO submodule.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.StableQuadratization","page":"Compiler Settings","title":"ToQUBO.Attributes.StableQuadratization","text":"StableQuadratization()\n\nWhen set, this boolean flag enables stable quadratization methods, thus yielding predictable results. This is intended to be used during tests or other situations where deterministic output is desired. On the other hand, usage in production is not recommended since it requires increased memory and processing resources.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Variable-and-Constraint-Encoding","page":"Compiler Settings","title":"Variable & Constraint Encoding","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.VariableEncodingBits\nToQUBO.Attributes.DefaultVariableEncodingBits\nToQUBO.Attributes.VariableEncodingATol\nToQUBO.Attributes.DefaultVariableEncodingATol\nToQUBO.Attributes.VariableEncodingMethod\nToQUBO.Attributes.DefaultVariableEncodingMethod\nToQUBO.Attributes.VariableEncodingPenalty\nToQUBO.Attributes.ConstraintEncodingPenalty","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingBits","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingBits","text":"VariableEncodingBits()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.DefaultVariableEncodingBits","page":"Compiler Settings","title":"ToQUBO.Attributes.DefaultVariableEncodingBits","text":"DefaultVariableEncodingBits()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingATol","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingATol","text":"VariableEncodingATol()\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.DefaultVariableEncodingATol","page":"Compiler Settings","title":"ToQUBO.Attributes.DefaultVariableEncodingATol","text":"DefaultVariableEncodingATol()\n\nFallback value for VariableEncodingATol.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingMethod","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingMethod","text":"VariableEncodingMethod()\n\nAvailable methods are:\n\nBinary (default)\nUnary\nArithmetic\nOneHot\nDomainWall\nBounded\n\nThe Binary, Unary and Arithmetic encodings can have their expansion coefficients bounded by parametrizing the Bounded encoding.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.DefaultVariableEncodingMethod","page":"Compiler Settings","title":"ToQUBO.Attributes.DefaultVariableEncodingMethod","text":"DefaultVariableEncodingMethod()\n\nFallback value for VariableEncodingMethod.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.VariableEncodingPenalty","page":"Compiler Settings","title":"ToQUBO.Attributes.VariableEncodingPenalty","text":"VariableEncodingPenalty()\n\nAllows the user to set and retrieve the coefficients used for encoding variables when additional constraints are involved.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#ToQUBO.Attributes.ConstraintEncodingPenalty","page":"Compiler Settings","title":"ToQUBO.Attributes.ConstraintEncodingPenalty","text":"ConstraintEncodingPenalty()\n\nAllows the user to set and retrieve the coefficients used for encoding constraints.\n\n\n\n\n\n","category":"type"},{"location":"manual/4-settings/#Discretization","page":"Compiler Settings","title":"Discretization","text":"","category":"section"},{"location":"manual/4-settings/","page":"Compiler Settings","title":"Compiler Settings","text":"ToQUBO.Attributes.Discretize","category":"page"},{"location":"manual/4-settings/#ToQUBO.Attributes.Discretize","page":"Compiler Settings","title":"ToQUBO.Attributes.Discretize","text":"Discretize()\n\nWhen set, this boolean flag guarantees that every coefficient in the final formulation is an integer.\n\n\n\n\n\n","category":"type"},{"location":"examples/prime_factorization/#Prime-Factorization","page":"Prime Factorization","title":"Prime Factorization","text":"","category":"section"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"A central problem in Number Theory and cryptography is to factor R in mathbbN, which is known to be the product of two distinct prime numbers p q in mathbbN. Shor's Algorithm, designed to address such task is often regarded as one of the major theoretical landmarks in Quantum Computing, being responsible for driving increasingly greater interest to the area.","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"A naïve approach to model this problem can be stated as a quadratically-constrained integer program:","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"beginarrayrl\ntextst  p times q = R \n             p q ge 0     \n             p q in mathbbZ\nendarray","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"From the definition and the basics of number theory, we are able to retrieve a few assumptions about the problem's variables:","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"p and q are bounded to the interval left1 Rright\nMoreover, it is fine to assume 1  p le sqrtR le q le R div 2.","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal\n\nfunction factor(R::Integer; optimizer = DWaveNeal.Optimizer)\n    return factor(identity, R; optimizer)\nend\n\nfunction factor(config!::Function, R::Integer; optimizer = DWaveNeal.Optimizer)\n    model = Model(() -> ToQUBO.Optimizer(optimizer))\n\n    @variable(model,  1 <= p <= √R, Int)\n    @variable(model, √R <= q <= R ÷ 2, Int)\n\n    @constraint(model, p * q == R)\n\n    config!(model)\n\n    optimize!(model)\n\n    p = round(Int, value(model[:p]))\n    q = round(Int, value(model[:q]))\n\n    return (p, q)\nend","category":"page"},{"location":"examples/prime_factorization/","page":"Prime Factorization","title":"Prime Factorization","text":"p, q = factor(15) do model\n    set_optimizer_attribute(model, \"num_reads\", 1_000)\n    set_optimizer_attribute(model, \"num_sweeps\", 2_000)\nend\n\nprint(\"$p, $q\")","category":"page"},{"location":"examples/portfolio_optimization/#Portfolio-Optimization","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"","category":"section"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"In this example, we will be exploring an optimization model for asset distribution where the expected return is maximized while mitigating the financial risk. The following approach was inspired by a JuMP tutorial, where monthly stock prices for three assets are provided, namely IBM, WMT and SEHI.","category":"page"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"The modelling presented below aggregates the risk measurement mathbfx Sigma mathbfx as a penalty term to the objective function, thus yielding","category":"page"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"beginarrayrll\n    max_mathbfx  mathbfmumathbfx - lambda mathbfx Sigma mathbfx             \n    textrmst      0 le x_i le 1                                                forall i \n                       sum_i x_i = 1\nendarray","category":"page"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"where mu_i = mathbbEr_i is the expected return value for each investment i; Sigma is the covariance matrix and lambda is the risk-aversion penalty factor.","category":"page"},{"location":"examples/portfolio_optimization/#Stock-prices","page":"Portfolio Optimization","title":"Stock prices","text":"","category":"section"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"using DataFrames\nusing Statistics\n\nassets = [:IBM, :WMT, :SEHI]\n\ndf = DataFrames.DataFrame(\n    [\n         93.043    51.826    1.063\n         84.585    52.823    0.938\n        111.453    56.477    1.000\n         99.525    49.805    0.938\n         95.819    50.287    1.438\n        114.708    51.521    1.700\n        111.515    51.531    2.540\n        113.211    48.664    2.390\n        104.942    55.744    3.120\n         99.827    47.916    2.980\n         91.607    49.438    1.900\n        107.937    51.336    1.750\n        115.590    55.081    1.800\n    ],\n    assets,\n)","category":"page"},{"location":"examples/portfolio_optimization/#Solving","page":"Portfolio Optimization","title":"Solving","text":"","category":"section"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal\n\nfunction solve(\n    config!::Function,\n    df::DataFrame,\n    λ::Float64 = 10.;\n    optimizer = DWaveNeal.Optimizer\n)\n    # Number of assets\n    n = size(df, 2)\n\n    # Relative monthly return\n    r = diff(Matrix(df); dims = 1) ./ Matrix(df[1:end-1, :])\n\n    # Expected monthly return value for each stock\n    μ = vec(Statistics.mean(r; dims = 1))\n\n    # Covariance matrix\n    Σ = Statistics.cov(r)\n\n    # Build model\n    model = Model(() -> ToQUBO.Optimizer(optimizer))\n\n    @variable(model, 0 <= x[1:n] <= 1)\n    @objective(model, Max, μ'x - λ * x' * Σ * x)\n    @constraint(model, sum(x) == 1)\n\n    config!(model)\n\n    optimize!(model)\n\n    return value.(x)\nend\n\nfunction solve(df::DataFrame, λ::Float64 = 10.; optimizer = DWaveNeal.Optimizer)\n    return solve(identity, df, λ; optimizer)\nend","category":"page"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"solve(df) do model\n    JuMP.set_silent(model)\n    JuMP.set_optimizer_attribute(model, \"num_reads\", 2_000)\nend","category":"page"},{"location":"examples/portfolio_optimization/#Penalty-Analysis","page":"Portfolio Optimization","title":"Penalty Analysis","text":"","category":"section"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"To finish our discussion, we are going to sketch some graphics to help our reasoning on how the penalty factor lambda affects our investments.","category":"page"},{"location":"examples/portfolio_optimization/","page":"Portfolio Optimization","title":"Portfolio Optimization","text":"using Plots; pythonplot()\n\nΛ = collect(0.:5.:50.)\nX = Dict{Symbol,Vector{Float64}}(tag => [] for tag in assets)\n\nfor λ = Λ\n    x = solve(df, λ)\n\n    for (i, tag) in enumerate(assets)\n        push!(X[tag], x[i])\n    end\nend\n\nplt = plot(;\n    title=\"Portfolio Optimization\",\n    xlabel=raw\"penalty factor ($\\lambda$)\",\n    ylabel=raw\"investment share ($x$)\",\n)\n\nfor tag in assets\n    plot!(plt, Λ, X[tag]; label=string(tag))\nend\n\nplt","category":"page"},{"location":"booklet/3-pbo/#Pseudo-Boolean-Optimization","page":"PBO","title":"Pseudo-Boolean Optimization","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"Internally, problems are represented through a Pseudo-Boolean Optimization (PBO) framework. The main goal is to represent a given problem using a Pseudo-Boolean Function (PBF) since there is an immediate correspondence between optimization over quadratic PBFs and the QUBO formalism.","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"ToQUBO.PBO.PseudoBooleanFunction","category":"page"},{"location":"booklet/3-pbo/#ToQUBO.PBO.PseudoBooleanFunction","page":"PBO","title":"ToQUBO.PBO.PseudoBooleanFunction","text":"PseudoBooleanFunction{V,T}(Ω::Dict{Union{Set{V},Nothing},T}) where {V,T}\n\nA Pseudo-Boolean Function[Boros2002] f in mathscrF over some field mathbbT takes the form\n\nf(mathbfx) = sum_omega in Omegaleftfright c_omega prod_j in omega x_j\n\nwhere each Omegaleftfright is the multi-linear representation of f as a set of terms. Each term is given by a unique set of indices omega subseteq mathbbS related to some coefficient c_omega in mathbbT. We say that omega in Omegaleftfright iff c_omega neq 0. Variables x_j are boolean, thus f  mathbbB^n to mathbbT.\n\n[Boros2002]: Endre Boros, Peter L. Hammer, Pseudo-Boolean optimization, Discrete Applied Mathematics, 2002 {doi}\n\n\n\n\n\n","category":"type"},{"location":"booklet/3-pbo/#Quadratization","page":"PBO","title":"Quadratization","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"In order to successfully achieve a QUBO formulation, sometimes it is needed to quadratize the resulting PBF, i.e., reduce its degree until reaching the quadratic case. ","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"A quadratization is a mapping mathcalQ mathscrF to mathscrF^2 such that","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"forall f in mathscrF forall x in 0 1^n min_y mathcalQleftlbracefrightrbrace(x y) = f(x)\n","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"There are many quadratization methods available[Dattani2019], and ToQUBO implements two of them for now. However, using Julia's multiple dispatch paradigm, it's possible to extend the quadratization method coverage with your own algorithms.","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"ToQUBO.PBO.quadratize!","category":"page"},{"location":"booklet/3-pbo/#ToQUBO.PBO.quadratize!","page":"PBO","title":"ToQUBO.PBO.quadratize!","text":"quadratize!(aux::Function, f::PBF{S, T}, ::Quadratization{Q}) where {S,T,Q}\n\nQuadratizes a given PBF in-place, i.e. applies a mapping mathcalQ  mathscrF^k to mathscrF^2, where mathcalQ is the quadratization method.\n\naux(::Nothing)::S\naux(::Integer)::Vector{S}\n\n\n\n\n\n","category":"function"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"[Dattani2019]: Nikesh S. Dattani, Quadratization in discrete optimization and quantum mechanics, ArXiv, 2019 {doi}","category":"page"},{"location":"booklet/3-pbo/#Implemented-Quadratization-Techniques","page":"PBO","title":"Implemented Quadratization Techniques","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"Currently, ToQUBO has two reduction algorithms, one for negative and another for positive terms.","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"ToQUBO.PBO.NTR_KZFD\nToQUBO.PBO.PTR_BG","category":"page"},{"location":"booklet/3-pbo/#ToQUBO.PBO.NTR_KZFD","page":"PBO","title":"ToQUBO.PBO.NTR_KZFD","text":"Quadratization{NTR_KZFD}(stable::Bool = false)\n\nNegative Term Reduction NTR-KZFD (Kolmogorov & Zabih, 2004; Freedman & Drineas, 2005)\n\nLet f(mathbfx) = x_1 x_2 dots x_k.\n\nmathcalQleftlbracefrightrbrace(mathbfx z) = (k - 1) z - sum_i = 1^k x_i z\n\nwhere mathbfx in mathbbB^k\n\ninfo: Info\nIntroduces a new variable z and no non-submodular terms.\n\n\n\n\n\n","category":"type"},{"location":"booklet/3-pbo/#ToQUBO.PBO.PTR_BG","page":"PBO","title":"ToQUBO.PBO.PTR_BG","text":"Quadratization{PTR_BG}(stable::Bool = false)\n\nPositive Term Reduction PTR-BG (Boros & Gruber, 2014)\n\nLet f(mathbfx) = x_1 x_2 dots x_k.\n\nmathcalQleftlbracefrightrbrace(mathbfx mathbfz) = left\n    sum_i = 1^k-2 z_i left( k - i - 1 + x_i + sum_j = i+1^k x_j right)\nright + x_k-1 x_k\n\nwhere mathbfx in mathbbB^k and mathbfz in mathbbB^k-2\n\ninfo: Info\nIntroduces k - 2 new variables z_1 dots z_k-2 and k - 1 non-submodular terms.\n\n\n\n\n\n","category":"type"},{"location":"booklet/3-pbo/#Stable-Quadratization","page":"PBO","title":"Stable Quadratization","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"The quadratization of a PBF does not guarantee that the resulting function will always be the same, as the order of terms can be different each time. This can be an issue in some situations where a deterministic output is required.","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"With said that, we have introduced the concept of Stable Quadratization, where the terms of the PBF are sorted, guaranteeing that the resulting PBF will be the same every time. We have defined it as an attribute of the compiler, with the  ToQUBO.Attributes.StableQuadratization flag.","category":"page"},{"location":"booklet/3-pbo/#A-Primer-on-Submodularity","page":"PBO","title":"A Primer on Submodularity","text":"","category":"section"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"A set function f  2^S to mathbbR is said to be submodular if","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"f(X cup Y) + f(X cap Y) le f(X) + f(Y) forall X Y subset S","category":"page"},{"location":"booklet/3-pbo/","page":"PBO","title":"PBO","text":"holds.","category":"page"},{"location":"booklet/6-compiler/#The-Compiler","page":"The Compiler","title":"The Compiler","text":"","category":"section"},{"location":"booklet/6-compiler/","page":"The Compiler","title":"The Compiler","text":"warning: Work in progress\nWe hope to write this part of the documentation soon. Please come back later!","category":"page"},{"location":"booklet/6-compiler/#Compilation-Steps","page":"The Compiler","title":"Compilation Steps","text":"","category":"section"},{"location":"booklet/6-compiler/","page":"The Compiler","title":"The Compiler","text":"ToQUBO.toqubo_sense!\nToQUBO.toqubo_variables!\nToQUBO.toqubo_constraint\nToQUBO.toqubo_constraints!\nToQUBO.toqubo_objective!\nToQUBO.toqubo_penalties!\nToQUBO.toqubo_parse!\nToQUBO.toqubo_build!","category":"page"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_sense!","page":"The Compiler","title":"ToQUBO.toqubo_sense!","text":"toqubo_sense!(model::VirtualModel, ::AbstractArchitecture) where {T}\n\nCopies MOI.ObjectiveSense from model.source_model to model.target_model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_variables!","page":"The Compiler","title":"ToQUBO.toqubo_variables!","text":"toqubo_variables!(model::VirtualModel{T}) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_constraints!","page":"The Compiler","title":"ToQUBO.toqubo_constraints!","text":"toqubo_constraints!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_objective!","page":"The Compiler","title":"ToQUBO.toqubo_objective!","text":"toqubo_objective!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_penalties!","page":"The Compiler","title":"ToQUBO.toqubo_penalties!","text":"toqubo_penalties!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_parse!","page":"The Compiler","title":"ToQUBO.toqubo_parse!","text":"toqubo_parse!(\n    model::VirtualModel{T},\n    g::PBO.PBF{VI,T},\n    f::MOI.AbstractFunction,\n    arch::AbstractArchitectur\n) where {T}\n\nParses the given MOI function f into PBF g.\n\n\n\n\n\n","category":"function"},{"location":"booklet/6-compiler/#ToQUBO.toqubo_build!","page":"The Compiler","title":"ToQUBO.toqubo_build!","text":"toqubo_build!(model::VirtualModel, ::AbstractArchitecture)\n\n\n\n\n\n","category":"function"},{"location":"manual/1-start/#Manual","page":"Getting Started","title":"Manual","text":"","category":"section"},{"location":"manual/1-start/#Quick-Start-Guide","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"manual/1-start/","page":"Getting Started","title":"Getting Started","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal # <- Your favourite Annealer/Sampler/Solver here\n\nmodel = Model(() -> ToQUBO.Optimizer(DWaveNeal.Optimizer))\n\n@variable(model, x[1:3], Bin)\n\n@objective(model, Max, 1.0 * x[1] + 2.0 * x[2] + 3.0 * x[3])\n\n@constraint(model, 0.3 * x[1] + 0.5 * x[2] + 1.0 * x[3] <= 1.6)\n\noptimize!(model)\n\nsolution_summary(model)","category":"page"},{"location":"manual/1-start/#Table-of-Contents","page":"Getting Started","title":"Table of Contents","text":"","category":"section"},{"location":"manual/1-start/","page":"Getting Started","title":"Getting Started","text":"Pages = [\"2-model.md\", \"3-results.md\", \"4-settings.md\"]\nDepth = 2","category":"page"},{"location":"booklet/2-qubo/#QUBO","page":"QUBO","title":"QUBO","text":"","category":"section"},{"location":"booklet/2-qubo/#Definition","page":"QUBO","title":"Definition","text":"","category":"section"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"Quadratic Unconstrained Binary Optimization, as the name suggests, refers to the global minimization or maximization of a quadratic polynomial on binary variables. A common presentation, the quadratic matrix form, is written as","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"beginarrayrl\n   min_mathbfx  mathbfx Qmathbfx \n   textrmst      mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"where Q in mathbbR^n times n is symmetric and mathbbB = lbrace0 1rbrace. Note that, since x^2 = x holds for x in mathbbB, the linear terms of the objective function are stored in the main diagonal of Q.","category":"page"},{"location":"booklet/2-qubo/#OK,-but-why-QUBO?","page":"QUBO","title":"OK, but why QUBO?","text":"","category":"section"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"Mathematically speaking, there is a notorious equivalence between QUBO and Max-Cut problems, e.g. for every QUBO instance there is an information preserving Max-Cut reformulation and vice versa. This statement is followed by two immediate implications:","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"In the general case, solving QUBO globally is NP-Hard.\nIt is a simple yet expressive mathematical programming framework.","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"Implication 1. tells us that such problems are computationally intractable and that heuristics and metaheuristics are to be employed instead of exact methods. No 2. relates to the fact that we are able to represent many other optimization models by means of the QUBO formalism.","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"The Ising Model, on the other hand, is a mathematical abstraction to describe statistical interactions within mechanical systems with interesting properties for encoding combinatorial problems. Its Hamiltonian leads to an optimization formulation in terms of the spin values of their states, given by","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"beginarrayrl\n   min_mathbfs  mathbfhmathbfs + mathbfs Jmathbfs \n   textrmst      mathbfs in lbrace-1+1rbrace^n\nendarray","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"with strictly upper triangular J in mathbbR^n times n and mathbfh in mathbbR.","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"(Image: D-Wave Washington 1000Q)","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"The Ising reformulation alternative draws the bridge between QUBO problems and devices designed to sample global or approximate ground states of the Ising Hamiltonian with high probability[Mohseni2022]. Some of the paradigms that stand out in this context are quantum gate-based optimization algorithms (QAOA and VQE), quantum annealers, hardware-accelerated platforms (Coherent Ising Machines and Simulated Bifurcation Machines) and physics-inspired methods (Simulated Annealing, Parallel Tempering). The significant advances in these computing systems contributed to the growing popularity of the model across the literature.","category":"page"},{"location":"booklet/2-qubo/","page":"QUBO","title":"QUBO","text":"[Mohseni2022]: Mohseni, N., McMahon, P. L. & Byrnes, T. Ising machines as hardware solvers of combinatorial optimization problems. Nat Rev Phys 4, 363–379 (2022). {arXiv}","category":"page"},{"location":"booklet/8-appendix/#Appendix","page":"Appendix","title":"Appendix","text":"","category":"section"},{"location":"booklet/8-appendix/#ToQUBO.jl's-Assets","page":"Appendix","title":"ToQUBO.jl's Assets","text":"","category":"section"},{"location":"booklet/8-appendix/#Logo","page":"Appendix","title":"Logo","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The ideia behind ToQUBO.jl's logo comes from a wordplay in Portuguese and Spanish. The package's main purpose is to assemble QUBO Models, which sounds like cubo[1], the translation for cube.","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"(Image: ToQUBO.jl Logo)","category":"page"},{"location":"booklet/8-appendix/#Colors","page":"Appendix","title":"Colors","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The colors were picked according to  Julia's Reference for logo graphics[2]. Text color matches the innermost shape and renders fairly well in both light and dark background themes.","category":"page"},{"location":"booklet/8-appendix/#Typography","page":"Appendix","title":"Typography","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The MADETYPE Sunflower[3] font was chosen. It was converted to a SVG path using the Google Font to Svg Path[4] online tool.","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[1]: IPA: [ˈkubʊ]","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[2]: github.com/JuliaLang/julia-logo-graphics","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[3]: Licensed by the authors for use in this project","category":"page"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"[4]: danmarshall.github.io/google-font-to-svg-path","category":"page"},{"location":"booklet/8-appendix/#Web-Icon-[![ToQUBO.jl-Icon](../../assets/favicon.ico)]()","page":"Appendix","title":"Web Icon (Image: ToQUBO.jl Icon)","text":"","category":"section"},{"location":"booklet/8-appendix/","page":"Appendix","title":"Appendix","text":"The icon used to decorate the documentation resembles an assembled version of the cube with its blue face making up the background.","category":"page"},{"location":"booklet/7-solvers/#QUBO-Solvers","page":"Solvers","title":"QUBO Solvers","text":"","category":"section"},{"location":"booklet/7-solvers/#Solvers,-Annealers-and-Samplers","page":"Solvers","title":"Solvers, Annealers & Samplers","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"ToQUBO.jl's main goal is to make use of parameterized stochastic optimization solvers, particularly those relying on non-conventional hardware such as Quantum Annealing and other Ising Machines. A few MOI-compliant interfaces for annealers and samplers are bundled within ToQUBO.jl via the QUBODrivers.jl companion package. Some of them are presented below.","category":"page"},{"location":"booklet/7-solvers/#Simulated-Annealing","page":"Solvers","title":"Simulated Annealing","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"Provided by D-Wave's open-source code libraries, this Simulated Annealing engine implements some of the features and configurations you would find using the Quantum API. Its adoption is recommended for basic usage, tests, and research due to its robustness, simplicity and ease of use. The DWaveNeal.jl package uses QUBODrivers.jl to deliver an interface to this sampler.","category":"page"},{"location":"booklet/7-solvers/#Quantum-Annealing","page":"Solvers","title":"Quantum Annealing","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"Interfacing with D-Wave's quantum annealer is one of the milestones we expect to achieve with this package. Like other proprietary optimization resources such as Gurobi, FICO® Xpress and IBM® CPLEX®, this requires licensing and extra steps are needed to get an access token. In a first moment, for those willing to get started, the DWaveNeal.jl optimizer might be enough to learn the ropes.","category":"page"},{"location":"booklet/7-solvers/#Random-Sampling","page":"Solvers","title":"Random Sampling","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"This sampler is implemented for test purposes and simply assigns 0 or 1 to each variable according to a given probability bias 0 le p le 1, which defaults to p = 05. After running the using QUBODrivers command, RandomSampler.Optimizer will be available.","category":"page"},{"location":"booklet/7-solvers/#Exact-Solver-(Exhaustive-Enumeration)","page":"Solvers","title":"Exact Solver (Exhaustive Enumeration)","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"Also made to be used in tests, the ExactSolver.Optimizer interface runs through all possible state configurations, which implies in an exponential time complexity on the number of variables. Thus, only problems with at most approxeq 20 variables should be provided since visiting 2^20 approxeq 10^6 states can already take up to a few seconds.","category":"page"},{"location":"booklet/7-solvers/#Mixed-Integer-Quadratic-Programming","page":"Solvers","title":"Mixed-Integer Quadratic Programming","text":"","category":"section"},{"location":"booklet/7-solvers/","page":"Solvers","title":"Solvers","text":"The most accessible alternative to the forementioned methods are Mixed-Integer Quadratic Programming (MIQP) solvers such as Gurobi, CPLEX, SCIP and BARON. These are not intended to be of regular use alongside ToQUBO.jl since providing a QUBO reformulation will usually make things harder for non-specialized solvers. Yet, there are still a few cases where they may be suitable, such as tests, benchmarks, or any other situation where global optimality is a must.","category":"page"},{"location":"manual/2-model/#Running-a-Model","page":"Running a Model","title":"Running a Model","text":"","category":"section"},{"location":"manual/2-model/","page":"Running a Model","title":"Running a Model","text":"warning: Work in progress\nWe hope to write this part of the documentation soon. Please come back later!","category":"page"},{"location":"booklet/5-virtual/#Virtual-Mapping","page":"Virtual Mapping","title":"Virtual Mapping","text":"","category":"section"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"During reformulation, ToQUBO holds two distinct models, namely the Source Model and the Target Model. The source model is a generic MOI model restricted to the supported constraints. The target one is on the QUBO form used during the solving process. Both lie within a Virtual Model, which provides the necessary API integration and keeps all variable and constraint mapping tied together.","category":"page"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"<script type=\"text/tikz\">\n  \\begin{tikzpicture}\n    \\draw (0,0) circle (1in);\n  \\end{tikzpicture}\n</script>","category":"page"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"This is done in a transparent fashion for both agents since the user will mostly interact with the presented model, and the solvers will only access the generated one.","category":"page"},{"location":"booklet/5-virtual/#Virtual-Model","page":"Virtual Mapping","title":"Virtual Model","text":"","category":"section"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"ToQUBO.VirtualModel","category":"page"},{"location":"booklet/5-virtual/#ToQUBO.VirtualModel","page":"Virtual Mapping","title":"ToQUBO.VirtualModel","text":"VirtualModel{T}(optimizer::Union{Nothing, Type{<:MOI.AbstractOptimizer}} = nothing) where {T}\n\nThis Virtual Model links the final QUBO formulation to the original one, allowing variable value retrieving and other features.\n\n\n\n\n\n","category":"type"},{"location":"booklet/5-virtual/#Virtual-Variables","page":"Virtual Mapping","title":"Virtual Variables","text":"","category":"section"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"Every virtual model stores a collection of virtual variables, intended to provide a link between those in the source and those to be created in the target model. Each virtual variable stores encoding information for later expansion and evaluation.","category":"page"},{"location":"booklet/5-virtual/","page":"Virtual Mapping","title":"Virtual Mapping","text":"ToQUBO.VirtualVariable\nToQUBO.encode!","category":"page"},{"location":"booklet/5-virtual/#ToQUBO.VirtualVariable","page":"Virtual Mapping","title":"ToQUBO.VirtualVariable","text":"Variable Expansion methods:\n\n- Linear\n- Unary\n- Binary\n- One Hot\n- Domain Wall\n\nReferences:\n\n[1] Chancellor, N. (2019). Domain wall encoding of discrete variables for quantum annealing and QAOA. Quantum Science and Technology, 4(4), 045004. {doi}\n\n\n\n\n\n","category":"type"},{"location":"booklet/5-virtual/#ToQUBO.encode!","page":"Virtual Mapping","title":"ToQUBO.encode!","text":"encode!(model::VirtualModel{T}, v::VirtualVariable{T}) where {T}\n\nMaps newly created virtual variable v within the virtual model structure. It follows these steps:\n\nMaps v's source to it in the model's source mapping.\nFor every one of v's targets, maps it to itself and adds a binary constraint to it.\nAdds v to the end of the model's varvec.  \n\n\n\n\n\n","category":"function"},{"location":"#ToQUBO.jl-Documentation","page":"Home","title":"ToQUBO.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ToQUBO.jl is a Julia Package intended to automatically translate models written in JuMP, into the QUBO mathematical optimization framework.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"ToQUBO\")","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal\n\nmodel = Model(() -> ToQUBO.Optimizer(DWaveNeal.Optimizer))\n\n@variable(model, x[1:3], Bin)\n@objective(model, Max, 1.0*x[1] + 2.0*x[2] + 3.0*x[3])\n@constraint(model, 0.3*x[1] + 0.5*x[2] + 1.0*x[3] <= 1.6)\n\noptimize!(model)\n\nsolution_summary(model)","category":"page"},{"location":"#Citing-ToQUBO.jl","page":"Home","title":"Citing ToQUBO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ToQUBO.jl in your work, we kindly ask you to include the following citation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{toqubo:2023,\n  author       = {Pedro Maciel Xavier and Pedro Ripper and Tiago Andrade and Joaquim Dias Garcia and David E. Bernal Neira},\n  title        = {{ToQUBO.jl}},\n  month        = {feb},\n  year         = {2023},\n  publisher    = {Zenodo},\n  version      = {v0.1.5},\n  doi          = {10.5281/zenodo.7644291},\n  url          = {https://doi.org/10.5281/zenodo.7644291}\n}","category":"page"},{"location":"examples/knapsack/#Knapsack","page":"Knapsack","title":"Knapsack","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"We start with some instances of the discrete Knapsack Problem whose standard formulation is","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"beginarrayr l\n    max         mathbfc mathbfx \n    textst  mathbfw mathbfx le C \n                mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"examples/knapsack/#MathOptInterface","page":"Knapsack","title":"MathOptInterface","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"Using MOI directly to build a simple model is pretty straightforward. All that one has to do is to use MOI.instantiate and define the model as usual.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"import MathOptInterface as MOI\nconst MOIU = MOI.Utilities\n\nusing ToQUBO\nusing DWaveNeal # <- Your favourite Annealer / Sampler / Solver here\n\n# Example from https://jump.dev/MathOptInterface.jl/stable/tutorials/example/\n\n# Virtual QUBO Model\nmodel = MOI.instantiate(\n   () -> ToQUBO.Optimizer(DWaveNeal.Optimizer),\n   with_bridge_type = Float64,\n)\n\nn = 3;\nc = [1.0, 2.0, 3.0]\nw = [0.3, 0.5, 1.0]\nC = 3.2;\n\nx = MOI.add_variables(model, n);\n\nfor xᵢ in x\n   MOI.add_constraint(model, xᵢ, MOI.ZeroOne())\nend\n\nMOI.set(model, MOI.ObjectiveSense(), MOI.MAX_SENSE)\n\nMOI.set(\n   model,\n   MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n   MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0),\n);\n\nMOI.add_constraint(\n   model,\n   MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(w, x), 0.0),\n   MOI.LessThan(C),\n);\n\nMOI.optimize!(model)\n\n# Collect Solution\nMOI.get.(model, MOI.VariablePrimal(), x)","category":"page"},{"location":"examples/knapsack/#JuMP-D-Wave-Examples","page":"Knapsack","title":"JuMP + D-Wave Examples","text":"","category":"section"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"We may now fill a few more knapsacks using JuMP. We will generate uniform random costs mathbfc and weights mathbfw then set the knapsack's capacity C to be a fraction of the total available weight i.e. 80.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"This example was inspired by D-Wave's knapsack example repository.","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using CSV\nusing DataFrames\nusing Random\n\n# Generate Data\nrng = MersenneTwister(1)\n\ndf = DataFrame(\n   :cost   => rand(rng, 1:100, 16),\n   :weight => rand(rng, 1:100, 16),\n)\n\nCSV.write(\"knapsack.csv\", df)","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using CSV\nusing DataFrames\n\ndf = CSV.read(\"knapsack.csv\", DataFrame)","category":"page"},{"location":"examples/knapsack/","page":"Knapsack","title":"Knapsack","text":"using JuMP\nusing ToQUBO\nusing DWaveNeal # <- Your favourite Annealer/Sampler/Solver here\n\nmodel = Model(() -> ToQUBO.Optimizer(DWaveNeal.Optimizer))\n\nn = size(df, 1)\nc = collect(Float64, df[!, :cost])\nw = collect(Float64, df[!, :weight])\nC = round(0.8 * sum(w))\n\n@variable(model, x[1:n], Bin)\n@objective(model, Max, c' * x)\n@constraint(model, w' * x <= C)\n\noptimize!(model)\n\n# Add Results as a new column\ninsertcols!(df, 3, :select => map((ξ) -> (ξ > 0.0) ? \"Yes\" : \"No\", value.(x)))","category":"page"}]
}
