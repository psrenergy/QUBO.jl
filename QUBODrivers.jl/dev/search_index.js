var documenterSearchIndex = {"docs":
[{"location":"interface/#A-new-Sampler","page":"A new Sampler","title":"A new Sampler","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"This guide aims to provide a tutorial on how to implement new sampler interfaces using QUBODrivers.jl.","category":"page"},{"location":"interface/#The-@setup-macro","page":"A new Sampler","title":"The @setup macro","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Using the QUBODrivers.@setup macro is the most straightforward way to get your sampler running right now. Apart from the macro call it is needed to implement the QUBODrivers.sample method.","category":"page"},{"location":"interface/#I.-Imports","page":"A new Sampler","title":"I. Imports","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"First of all, we are going to import both QUBODrivers.jl and also MathOptInterface.jl, commonly aliased as MOI.","category":"page"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"import QUBODrivers\nimport MathOptInterface\nconst MOI = MathOptInterface","category":"page"},{"location":"interface/#II.-@setup","page":"A new Sampler","title":"II. @setup","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"This macro takes two arguments: the identifier of the sampler's struct, and a begin...end block containing configuration parameters as key-value pairs. If ommited, the first defaults to Optimizer, following regular MOI conventions. In order to work smoothly, this approach leverages the QUBOTools backend.","category":"page"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"We expect that most users will be happy with this approach and it is likely that it will be improved and receive support very often.","category":"page"},{"location":"interface/#MathOptInterface-API-Coverage","page":"A new Sampler","title":"MathOptInterface API Coverage","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"This Document is intended to help keeping track of which MOI API Methods and Properties have been implemented for a new solver or model interface.","category":"page"},{"location":"interface/#Reference:","page":"A new Sampler","title":"Reference:","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"jump.dev/MathOptInterface.jl/stable/tutorials/implementing/","category":"page"},{"location":"interface/#Optimizer-Interface","page":"A new Sampler","title":"Optimizer Interface","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Method Status\nMOI.empty!(::Optimizer) ✅\nMOI.is_empty(::Optimizer)::Bool ✅\nMOI.optimize!(::Optimizer, ::MOI.ModelLike) ✅\nBase.show(::IO, ::Optimizer) ✔️","category":"page"},{"location":"interface/#The-copy_to-interface","page":"A new Sampler","title":"The copy_to interface","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Method Status\nMOI.copy_to(::Optimizer, ::MOI.ModelLike) ✅","category":"page"},{"location":"interface/#Constraint-Support","page":"A new Sampler","title":"Constraint Support","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Method Status\nMOI.supports_constraint(::Optimizer, ::F, ::S)::Bool where {F, S} ✔️","category":"page"},{"location":"interface/#Attributes","page":"A new Sampler","title":"Attributes","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Property Type get set supports\nMOI.SolverName String Ⓜ️ - -\nMOI.SolverVersion String Ⓜ️ - -\nMOI.RawSolver String ✔️ - -\nMOI.Name String Ⓜ️ Ⓜ️ Ⓜ️\nMOI.Silent Bool Ⓜ️ Ⓜ️ Ⓜ️\nMOI.TimeLimitSec Float64 Ⓜ️ Ⓜ️ Ⓜ️\nMOI.RawOptimizerAttribute Any Ⓜ️ Ⓜ️ Ⓜ️\nMOI.NumberOfThreads Int Ⓜ️ Ⓜ️ Ⓜ️","category":"page"},{"location":"interface/#Solution","page":"A new Sampler","title":"Solution","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Property Type get set supports\nMOI.PrimalStatus MOI.ResultStatusCode Ⓜ️ - -\nMOI.DualStatus MOI.ResultStatusCode Ⓜ️ - -\nMOI.RawStatusString String Ⓜ️ - -\nMOI.ResultCount Int Ⓜ️ - -\nMOI.TerminationStatus MOI.TerminationStatusCode Ⓜ️ - -\nMOI.ObjectiveValue T Ⓜ️ - -\nMOI.SolveTimeSec Float64 Ⓜ️ - -\nMOI.VariablePrimal T Ⓜ️ - -","category":"page"},{"location":"interface/#Warm-Start","page":"A new Sampler","title":"Warm Start","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Property Type get set supports\nMOI.VariablePrimalStart T Ⓜ️ Ⓜ️ Ⓜ️","category":"page"},{"location":"interface/#Key","page":"A new Sampler","title":"Key","text":"","category":"section"},{"location":"interface/","page":"A new Sampler","title":"A new Sampler","text":"Symbol Meaning\nⓂ️ Implemented via the @setup macro\n✅ Available for Sampler{T}\n✔️ Available for AbstracSampler{T}\n⚠️ Must be implemented\n❌ Not implemented, but you can do it if you want to","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Solving-Simple-QUBO-Model-with-QUBODrivers's-[RandomSampler](@ref-random-sampler)","page":"Examples","title":"Solving Simple QUBO Model with QUBODrivers's RandomSampler","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using JuMP\nusing QUBODrivers\n\nmodel = Model(RandomSampler.Optimizer)\n\nQ = [\n    -1.0  2.0  2.0\n     2.0 -1.0  2.0\n     2.0  2.0 -1.0\n]\n\n@variable(model, x[1:3], Bin)\n@objective(model, Min, x' * Q * x)\n\noptimize!(model)","category":"page"},{"location":"examples/#Recover-Results","page":"Examples","title":"Recover Results","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"for i = 1:result_count(model)\n    # State vector\n    xi = value.(x; result=i)\n\n    # Energy\n    yi = objective_value(model; result=i)\n\n    # Sampling Frequency\n    ri = reads(model; result=i)\n\n    println(\"f($xi) = $(yi)\\t×$(ri)\")\nend","category":"page"},{"location":"examples/#Plot:-Sampling-distribution","page":"Examples","title":"Plot: Sampling distribution","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\n\n# Extract SampleSet\nω = sampleset(model)\n\nplot(ω)","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Introduction","page":"Manual","title":"Introduction","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The core idea behind this package is to provide a toolbox for developing and integrating QUBO sampling tools with the JuMP mathematical programming environment. Appart from the few couple exported utility engines, QUBODrivers.jl is inherently about extensions, which is achieved by implementing most of the MOI requirements, leaving only the essential for the developer.","category":"page"},{"location":"manual/#QUBO","page":"Manual","title":"QUBO","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"An optimization problem is in its QUBO form if it is written as","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"beginarrayrl\n           min  alpha left mathbfxmathbfQmathbfx + mathbfellmathbfx + beta right \n    textst  mathbfx in S cong mathbbB^n\nendarray","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"with linear terms mathbfell in mathbbR^n and quadratic mathbfQ in mathbbR^n times n. alpha beta in mathbbR are, respectively, the scaling and offset factors.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The MOI-JuMP optimizers defined using the QUBODrivers.AbstractSampler{T} <: MOI.AbstractOptimizer interface only support models given in the QUBO form. QUBODrivers.jl employs QUBOTools on many tasks involving data management and querying. It is worth taking a look at QUBOTool's docs.","category":"page"},{"location":"manual/#Defining-a-new-sampler-interface","page":"Manual","title":"Defining a new sampler interface","text":"","category":"section"},{"location":"manual/#Showcase","page":"Manual","title":"Showcase","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Before explaining in detail how to use this package, it's good to list a few examples for the reader to grasp. Below, there are links to the files where the actual interfaces are implemented, including thin wrappers, interfacing with Python and Julia implementations of common algorithms and heuristics.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Project Source Code\nDWaveNeal.jl DWaveNeal\nIsingSolvers.jl GreedyDescent\n ILP\n MCMCRandom\nQuantumAnnealingInterface.jl QuantumAnnealingInterface","category":"page"},{"location":"manual/#The-[@setup](@id-setup)-macro","page":"Manual","title":"The @setup macro","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"QUBODrivers.@setup is available to speed up the interface setup process. This mechanism was created to reach the majority of the target audience, that is, researchers interested in integrating their QUBO/Ising samplers in a common optimization ecossystem.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"QUBODrivers.@setup","category":"page"},{"location":"manual/#QUBODrivers.@setup","page":"Manual","title":"QUBODrivers.@setup","text":"@setup(expr)\n\nThe @setup macro receives a begin ... end block with an attribute definition on each of the block's statements.\n\nAll attributes must be presented as an assignment to the default value of that attribute. To create a MathOptInterface optimizer attribute, an identifier must be present on the left hand side. If a solver-specific, raw attribute is desired, its name must be given as a string, e.g. between double quotes. In the special case where an attribute could be accessed in both ways, the identifier must be followed by the parenthesised raw attribute string. In any case, the attribute type can be specified typing the type assertion operator :: followed by the type itself just before the equal sign.\n\nFor example, a list of the valid syntax variations for the number of reads attribute follows:     - \"num_reads\" = 1_000     - \"num_reads\"::Integer = 1_000     - NumberOfReads = 1_000     - NumberOfReads::Integer = 1_000     - NumberOfReads[\"num_reads\"] = 1_000     - NumberOfReads[\"num_reads\"]::Integer = 1_000\n\nExample\n\nQUBODrivers.@setup Optimizer begin\n    name    = \"Super Sampler\"\n    sense   = :max\n    domain  = :spin\n    version = v\"1.0.2\"\n    attributes = begin\n        NumberOfReads[\"num_reads\"]::Integer = 1_000\n        SuperAttribute[\"super_attr\"] = nothing\n    end\nend\n\n\n\n\n\n","category":"macro"},{"location":"manual/","page":"Manual","title":"Manual","text":"Inside a module scope for the new interface, one should call the QUBODrivers.@setup macro, specifying the solver's attributes as described in the macro's docs. The second and last step is to define the QUBODrivers.sample(::Optimizer) method, that must return a QUBODrivers.SampleSet.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Using it might be somehow restrictive in comparison to the regular JuMP/MOI Solver Interface workflow. Yet, our guess is that most of this package's users are not considering going deeper into the MOI internals that soon.","category":"page"},{"location":"manual/#[@setup](@ref-setup-macro)-example","page":"Manual","title":"@setup example","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The following example is intended to illustrate the usage of the macro, showing how simple it should be to implement a wrapper for a sampler implemented in another language such as C or C++.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"module SuperSampler\n    using QUBODrivers\n\n    QUBODrivers.@setup Optimizer begin\n        name    = \"Super Sampler\"\n        sense   = :max\n        domain  = :spin\n        version = v\"1.0.2\"\n        attributes = begin\n            SuperAttribute::String = \"super\"\n            NumberOfReads[\"num_reads\"]::Integer = 1_000\n        end\n    end\n\n    model = Model(SuperSampler.Optimizer)\n\n    @variable(model, x[1:n], Bin)\n    @objective(model, Min, x' * Q * x)\n\n    function QUBODrivers.sample(sampler::Optimizer{T}) where {T}\n        # ~ Is your annealer running on the Ising Model? Have this:\n        h, J, u, v = QUBODrivers.ising(\n            sampler,\n            Vector, # Here we opt for a sparse, vector representation\n        )\n\n        n = MOI.get(sampler, MOI.NumberOfVariables())\n\n        # ~ Retrieve Attributes ~ #\n        num_reads = MOI.get(sampler, NumberOfReads())\n        @assert num_reads > 0\n\n        super_attr = MOI.get(sampler, SuperAttribute())\n        @assert super_attr ∈ (\"super\", \"ultra\", \"mega\")    \n\n        # ~*~ Timing Information ~*~ #\n        time_data = Dict{String,Any}()\n\n        # ~*~ Run Algorithm ~*~ #\n        result = @timed Vector{Int}[\n            super_sample(h, J, u, v; attr=super_attr)\n            for _ = 1:num_reads\n        ]\n        states = result.value\n\n        # ~*~ Record Time ~*~ #\n        time_data[\"effective\"] = result.time\n\n        metadata = Dict{String,Any}(\n            \"time\"   => time_data,\n            \"origin\" => \"Super Sampling method\"\n        )\n\n        # ~ Here some magic happens:\n        #   By providing the sampler and a vector of states,\n        #   QUBODrivers.jl computes the energy and organizes your\n        #   solutions automatically, following the variable\n        #   domain conventions specified previously.\n        return QUBODrivers.SampleSet{T}(sampler, states, metadata)\n    end\n\n    function super_sample(h, J, u, v; super_attr, kws...)\n        return ccall(\n            :super_sample,\n            Vector{Int},\n            (\n                Ptr{Cdouble},\n                Ptr{Cdouble},\n                Ptr{Cdouble},\n                Ptr{Cdouble},\n                Cint,\n                Cstring,\n            ),\n            h,\n            J,\n            u,\n            v,\n            super_attr,\n        )\n    end\nend","category":"page"},{"location":"manual/#Walkthrough","page":"Manual","title":"Walkthrough","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Now, it's time to go through the example in greater detail. First of all, the entire work must be done within a module.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"module SuperSampler\n    using QUBODrivers","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"By provding the using QUBODrivers statement, very little will be dumped into the namespace apart from the MOI = MathOptInterface constant. MOI's methods will soon be very important to access our optimizer's attributes.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"QUBODrivers.@setup Optimizer begin\n    name    = \"Super Sampler\"\n    sense   = :max\n    domain  = :spin\n    version = v\"1.0.2\"\n    attributes = begin\n        SuperAttribute::String = \"super\"\n        NumberOfReads[\"num_reads\"]::Integer = 1_000\n    end\nend","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The first parameter in the @setup call is the optimizer's identifier. It defaults to Optimizer and, in this case, is responsible for defining the Optimizer{T} <: MOI.AbstractOptimizer struct. A begin...end block comes next, with a few key-value pairs.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"info: Info\nOur solver, when deployed to be used within JuMP, will probably have its users to follow the usual construct:using JuMP\nusing SuperSampler\n\nmodel = Model(SuperSampler.Optimizer)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The solver name must be a string, and will be used as the return value for MOI.get(::Optimizer, ::MOI.SolverName()).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"name = \"Super Sampler\"","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The sense and domain values indicate how our new solvers expect its models to be presented and, even more importantly, how the resulting samples should be interpreted. Their values must be either :min or :max and :boll or :spin, respectively. Strings, symbols and literals are supported as input for these fields.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"sense  = :max\ndomain = :spin","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The other metadata entry is the version assignment, which is returned by MOI.get(::Optimizer, ::MOI.SolverVersion()). In order to consistently support semantic versioning it is required that the version number comes as a v-string e.g. v\"major.minor.patch\".","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"version = v\"1.0.2\"","category":"page"},{"location":"manual/#Model-Mapping","page":"Manual","title":"Model Mapping","text":"","category":"section"},{"location":"manual/#Automatic-Tests","page":"Manual","title":"Automatic Tests","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"QUBODrivers.test","category":"page"},{"location":"manual/#QUBODrivers.test","page":"Manual","title":"QUBODrivers.test","text":"test(optimizer::Type{S}; examples::Bool=false) where {S<:AbstractSampler}\ntest(config!::Function, optimizer::Type{S}; examples::Bool=false) where {S<:AbstractSampler}\n\n\n\n\n\n","category":"function"},{"location":"#QUBODrivers.jl-Documentation","page":"Home","title":"QUBODrivers.jl Documentation","text":"","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package aims to provide a common MOI-compliant API for QUBO Sampling & Annealing machines. It also contains a few utility samplers and testing tools for performance comparison, sanity checks and basic analysis features.","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QUBODrivers.jl is registered in Julia's General Registry and is available for download using the standard package manager.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> import Pkg\n\njulia> Pkg.add(\"QUBODrivers\")","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using JuMP\nusing QUBODrivers\n\nmodel = Model(ExactSampler.Optimizer)\n\nQ = [\n    -1.0  2.0  2.0\n     2.0 -1.0  2.0\n     2.0  2.0 -1.0\n]\n\n@variable(model, x[1:3], Bin)\n@objective(model, Min, x' * Q * x)\n\noptimize!(model)\n\nfor i = 1:result_count(model)\n    xi = value.(x; result=i)\n    yi = objective_value(model; result=i)\n    ri = reads(model; result=i)\n\n    println(\"f($xi) = $yi ($ri)\")\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!– ## Citing QUBODrivers.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{QUBODrivers.jl:2023,\n  author = {Pedro Xavier and Pedro Ripper and Tiago Andrade and Joaquim Garcia and David Bernal},\n  title        = {QUBODrivers.jl},\n  month        = {apr},\n  year         = {2023},\n  publisher    = {Zenodo},\n  version      = {v0.1.0},\n  doi          = {10.5281/zenodo.6390515},\n  url          = {https://doi.org/10.5281/zenodo.6390515}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"–>","category":"page"},{"location":"samplers/#Samplers","page":"Samplers","title":"Samplers","text":"","category":"section"},{"location":"samplers/#abstract-sampler","page":"Samplers","title":"Abstract Sampler","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"QUBODrivers.AbstractSampler","category":"page"},{"location":"samplers/#QUBODrivers.AbstractSampler","page":"Samplers","title":"QUBODrivers.AbstractSampler","text":"AbstractSampler{T} <: MOI.AbstractOptimizer\n\n\n\n\n\n","category":"type"},{"location":"samplers/#identity-sampler","page":"Samplers","title":"Identity Sampler","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"QUBODrivers.IdentitySampler.Optimizer","category":"page"},{"location":"samplers/#QUBODrivers.IdentitySampler.Optimizer","page":"Samplers","title":"QUBODrivers.IdentitySampler.Optimizer","text":"IdentitySampler.Optimizer{T}\n\nThis sampler selects precisely the state vector provided as warm-start.\n\n\n\n\n\n","category":"type"},{"location":"samplers/#exact-sampler","page":"Samplers","title":"Exact Sampler","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"QUBODrivers.ExactSampler.Optimizer","category":"page"},{"location":"samplers/#QUBODrivers.ExactSampler.Optimizer","page":"Samplers","title":"QUBODrivers.ExactSampler.Optimizer","text":"ExactSampler.Optimizer{T}\n\nThis sampler performs an exhaustive search over all 2^n possible states.\n\nwarn: Warn\nDue to the exponetially large amount of visited states, it is not possible to use this sampler for problems any larger than 20 variables big.\n\n\n\n\n\n","category":"type"},{"location":"samplers/#random-sampler","page":"Samplers","title":"Random Sampler","text":"","category":"section"},{"location":"samplers/","page":"Samplers","title":"Samplers","text":"QUBODrivers.RandomSampler.Optimizer","category":"page"},{"location":"samplers/#QUBODrivers.RandomSampler.Optimizer","page":"Samplers","title":"QUBODrivers.RandomSampler.Optimizer","text":"RandomSampler.Optimizer{T}\n\nAttributes\n\nRandomSeed, \"seed\": Random seed to initialize the random number generator.\nNumberOfReads, \"num_reads\": Number of random states sampled per run.\nRandomGenerator, \"rng\": Random Number Generator instance.\n\n\n\n\n\n","category":"type"}]
}
